reframe(sum_final = sum(sum1))
}
return(cov_loss_rate)
}
vcv.pairwise <- function(tree, alpha, sigma2, tip1, tip2){
mrca_node <- ape::mrca(tree)[tip1, tip2]
cov_accum = cov.accum(tree, mrca_node, alpha, sigma2)
cov_loss1 = cov.loss(tree, mrca_node, alpha, tip1)
cov_loss2 = cov.loss(tree, mrca_node, alpha, tip2)
cov = cov_accum * exp(cov_loss1 + cov_loss2)
return(unlist(unname(cov)))
}
vcv.matrix <- function(tree, alpha, sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, alpha, sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
colnames(V) <- tree$tip.label
rownames(V) <- tree$tip.label
return(V)
}
sd_logL_vcv <- function(tree, continuousChar, alpha, sigma2, theta){
alpha = alpha[sort(names(alpha))]
sigma2 = sigma2[sort(names(sigma2))]
theta = theta[sort(names(theta))]
theta = as.matrix(theta, nrow = 3)
ntip <- length(tree$tip.label)
V = vcv.matrix(tree, alpha, sigma2)
W = weight.matrix(tree, alpha)
C = chol(V) # upper triangular matrix
L = t(C) # lower triangular matrix
log_det_V = 0
for (i in 1:ntip){
log_det_V = log_det_V + log(L[i,i])
}
log_det_V = log_det_V * 2.0 # equals to julia implementation to 12 sig. fig.
y = NULL
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
# inverse of L
r = solve(L) %*% y - solve(L) %*% W %*% theta # what does de-correlated residuals mean?
# res = - (n/2) * log(2*pi) - 0.5 * log_det_V - 0.5 * dot(r, r)
#     = exp(-n/2)^(2*pi) * exp(-0.5)^det_V * exp(-0.5)^dot(r, r) ?
res = 0.0
res = res - (ntip/2) * log(2*pi)
res = res - 0.5 * log_det_V
res = res - 0.5 * dot(r, r) # is it dot product? what is dot product of r?
return(res)
}
# From slouch
data("artiodactyla")
data("neocortex")
neocortex <- neocortex[match(artiodactyla$tip.label, neocortex$species), ]
# Example
tree <- artiodactyla
brain <- neocortex$brain_mass_g_log_mean
names(brain) <- tree$tip.label
# Example
diet <- as.character(neocortex$diet)
names(diet) <- neocortex$species
discrete_states <- unique(diet)
set.seed(123)
tree <- make.simmap(artiodactyla, diet)
plot(tree)
#alpha = c(rep(rgamma(n=1, shape=1, rate=10), 3))
alpha = rgamma(n=3, shape=1, rate=10)
names(alpha) = discrete_states
#sigma2 = c(rep(rgamma(n=1, shape=2, rate=10), 3))
sigma2 = rgamma(n=3, shape=2, rate=10)
names(sigma2) = discrete_states
#theta = c(rep(rnorm(1, mean = 0, sd = 3), 3))
theta = rnorm(3, mean = 0, sd = 3)
names(theta) = discrete_states
likelihood_difference = c()
bar = txtProgressBar(style=3, width=40)
for (i in 1:100){
alpha = rgamma(n=3, shape=1, rate=10)
sigma2 = rgamma(n=3, shape=2, rate=10)
theta = rnorm(3, mean = 0, sd = 3)
names(alpha) = discrete_states
names(sigma2) = discrete_states
names(theta) = discrete_states
l2 = sd_logL_pruning(tree, brain, alpha, sigma2, theta)
l1 = sd_logL_vcv(tree, brain, alpha, sigma2, theta)
likelihood_difference[i] = abs(l1 - l2)
setTxtProgressBar(bar, i / 100)
}
hist(log(likelihood_difference), breaks = 20)
ggplot(as.data.frame(likelihood_difference)) +
geom_point(aes(x = 1:50, y = likelihood_difference))
ggplot(as.data.frame(likelihood_difference)) +
geom_point(aes(x = 1:100, y = log(likelihood_difference)))
ggplot(as.data.frame(likelihood_difference)) +
geom_histogram(aes(y = log(likelihood_difference)))
ggplot(as.data.frame(likelihood_difference)) +
geom_histogram(aes(log(likelihood_difference)))
ggplot(as.data.frame(likelihood_difference)) +
geom_histogram(aes(likelihood_difference))
ggplot(as.data.frame(likelihood_difference)) +
geom_boxplot(aes(likelihood_difference))
save(plt, "Desktop/likelihood_difference_box.pdf")
plt <- ggplot(as.data.frame(likelihood_difference)) +
geom_boxplot(aes(likelihood_difference))
save(plt, "Desktop/likelihood_difference_box.pdf")
ggsave(plt, "Desktop/likelihood_difference_box.pdf")
?ggsave
ggplot(as.data.frame(likelihood_difference)) +
geom_boxplot(aes(likelihood_difference))
ggsave("Desktop/likelihood_difference_box.pdf")
ggplot(as.data.frame(likelihood_difference)) +
geom_histogram(aes(likelihood_difference))
ggsave("Desktop/likelihood_difference_box.pdf")
library(phytools)
read.simmap("Desktop/statedependentOU/test_simmap_write.txt")
read.simmap("Desktop/statedependentOU/test_simmap_write.txt", format = "phylip")
remotes::install_github("thej022214/OUwie")
library(OUwie)
data(tworegime)
# simulate an OUM model
Q <- matrix(c(-1,1,1,-1), 2, 2)
root.freqs <- c(1, 0)
alpha <- c(2, 2)
sigma.sq <- c(1,1)
theta0 <- 5
theta <- c(5, 10)
simulated_data <- hOUwie.sim(tree, Q, root.freqs, alpha, sigma.sq, theta0, theta)
plot(simulated_data$simmap)
hOUwie.fixed(simmaps=simulated_data$simmap,
data=simulated_data$data,
rate.cat=1,
discrete_model="SYM",
continuous_model"OUMVA",
getOUParamStructure(model="OUMVA",nObsState = 2, rate.cat = 1)
hOUwie.fixed(simmaps=simulated_data$simmap,
data=simulated_data$data,
rate.cat=1,
discrete_model="SYM",
continuous_model=getOUParamStructure(model="OUMVA",nObsState = 2, rate.cat = 1),
root.p              = 5)
simulated_data$simmap
getOUParamStructure(model="OUMVA",nObsState = 2, rate.cat = 1)
hOUwie.fixed(simmaps=simulated_data$simmap,
data=simulated_data$data,
rate.cat=1,
discrete_model=matrix(c(-1,1,1,-1), 2, 2),
continuous_model=getOUParamStructure(model="OUMVA",nObsState = 2, rate.cat = 1),
root.p              = 5)
tree <- simulated_data$simmap
data <- simulated_data$data
hOUwie.fixed(simmaps=tree,
data=data,
rate.cat=1,
discrete_model=matrix(c(-1,1,1,-1), 2, 2),
continuous_model=getOUParamStructure(model="OUMVA",nObsState = 2, rate.cat = 1),
root.p              = 5)
read.simmap()
phytools::read.simmap()
library(slouch)
load(artiodactyl)
load(artiodactyla)
load("artiodactyla")
data("artiodactyla")
library(ape)
library(phytools)
write.tree(artiodactyla, "Desktop/statedependentOU/data/1_validation/artiodactyla/artiodactyla.tree")
library(ape)
t <- read.tree("Desktop/statedependentOU/data/3_empirical/mammal_2022.tree")
t <- read.tree("Desktop/statedependentOU/data/3_empirical/mammal_2019.trees")[1]
t <- read.simmap("Desktop/statedependentOU/data/3_empirical/mammal_2022.tree", format="phylip")
library(phytools)
t <- read.simmap("Desktop/statedependentOU/data/3_empirical/mammal_2022.tree", format="phylip")
library(phytools)
?make.simmap
library(phytools)
read.simmap("Desktop/statedependentOU/output/3_empirical/mammal_diet/02_state-dependentBM.tre")
tree <- read.simmap("Desktop/statedependentOU/output/3_empirical/mammal_diet/02_state-dependentBM.tre", format = "phylip")
setwd("Desktop/statedependentOU/")
library(ape)
library(phytools)
library(geiger)
library(TESS)
library(tidyverse)
drawHalflife <- function(linked, state_dependent, num_state, root_age){
if (isTRUE(linked)){
# can it be extended to more than 2 states?
halflife <- c(runif(1, 0.1*root_age, root_age))
if(num_state == 2){
x = rnorm(1, 0, 0.2)
while (abs(x) > halflife[1] | halflife[1]+x > 1 ){
x = rnorm(1, 0, 0.2)
}
halflife[2] <- halflife[1] + x
} else if (num_state == 3){
x <- rnorm(1, 0, 0.2)
while (abs(x) > halflife[1] | halflife[1]+x > 1 | halflife[1]-x < 0.05){
x = rnorm(1, 0, 0.2)
}
halflife[2] <- halflife[1] + x
halflife[3] <- halflife[1] - x
} else {
print(paste("Linked stv only supports 2 and 3-state currently."))
}
} else {
if(state_dependent == T){
halflife <- runif(n=num_state, 0.1*root_age, root_age)
} else {
#halflife <- rep(rlnorm(n=1, meanlog=4.349757, sdlog=1.044495), 3)
halflife <- rep(runif(n=1, 0.1*root_age, root_age), 3)
}
}
names(halflife) = c(1:(num_state))
return(halflife)
}
drawStv <- function(linked, state_dependent, num_state){
#not yet finished
if (isTRUE(linked)){
# can it be extended to more than 2 states?
stv <- c(runif(1, -8, 8))
if(num_state == 2){
stv[2] <- stv[1] + rnorm(1, 0, 4)
} else if (num_state == 3){
x <- rnorm(1, 0, 4)
stv[2] <- stv[1] + x
stv[3] <- stv[1] - x
} else {
print(paste("Linked stv only supports 2 and 3-state currently."))
}
} else {
if(isTRUE(state_dependent)){
stv <- rlnorm(n=num_state, meanlog=log(12.39783716), sdlog=0.587405)
} else {
stv <- rep(rlnorm(n=1, meanlog=log(12.39783716), sdlog=0.587405), num_state)
}
}
names(stv) = c(1:(num_state))
return(stv)
}
drawTheta <- function(linked, state_dependent, num_state){
if (isTRUE(linked)){
# can it be extended to more than 2 states?
theta <- c(runif(1, -10, 10))
if(num_state == 2){
x <- rnorm(1, 0, 4)
#while (abs(x+theta[1]) > 8){
#  x <- rnorm(1, 0, 4)
#}
theta[2] <- theta[1] + x
} else if (num_state == 3){
x <- rnorm(1, 0, 4)
#while (abs(x+theta[1]) > 8 | abs(x-theta[1]) > 8){
#  x <- rnorm(1, 0, 4)
#}
theta[2] <- theta[1] + x
theta[3] <- theta[1] - x
} else {
print(paste("Linked theta only supports 2 and 3-state currently."))
}
} else {
if(isTRUE(state_dependent)){
theta <- c(runif(n=num_state, -8, 8))
} else {
theta <- rep(runif(n=1, -8, 8), num_state)
}
}
names(theta) = c(1:(num_state))
return(theta)
}
simulateContinuous = function(tree, alpha, sigma2, theta) {
preorder <- rev(postorder(tree))
edges <- tree$edge
root_node <- length(tree$tip.label) + 1
state = tree$node.states[root_node]
mu_at_nodes <- rep(0, length(tree$node.states))
mu_at_nodes[root_node] <- theta[[state]]
for (edge_index in preorder){
sub_edges <- tree$maps[[edge_index]]
parent_node <- edges[edge_index, 1]
y <- mu_at_nodes[parent_node]
for (j in 1:length(sub_edges)) {
#alpha <- drawAlpha(state_dependent = stateDependencies[1])
#sigma2 <- drawAlpha(state_dependent = stateDependencies[2])
#theta <- drawAlpha(state_dependent = stateDependencies[3])
state <- names(sub_edges[j])
mu <- y * exp(-alpha[[state]] * sub_edges[[j]]) + theta[[state]] * (1 - exp(-alpha[[state]] * sub_edges[[j]]))
v <- sigma2[[state]] / (2 * alpha[[state]]) * (1 - exp(-2 * alpha[[state]] * sub_edges[[j]]))
y <- rnorm(n=1, mu, sqrt(v))
}
desc_node <- edges[edge_index, 2]
mu_at_nodes[desc_node] <- y
}
cont_list <- list()
for (i in 1:length(tree$tip.label)){
tip <- tree$tip.label[i]
cont_list[[tip]] <- mu_at_nodes[i]
}
return(cont_list)
}
# simulate continuous traits for power_sigma2
num_sim = 200
num_state = 2
emp = 12.39783716
#stv = c(0.5 * emp, emp, 2 * emp)
halflife=c(0.1, 0.3, 0.6)
theta_1 = c(1, 3, 5)
root_age = max(node.depth.edgelength(tree))
grid = expand.grid(sim=1:num_sim, halflife=halflife, theta_1=theta_1,
stv_1=NA, stv_2, sigma2_1=NA, sigma2_2=NA)
#simulation for exploring power of each OU parameter
tree <- read.tree("data/2_simulation/mammal_diet_height1_n500.tre")
i=1
# simulate continuous traits for power_sigma2
halflife=c(0.1, 0.3, 0.6)
theta_1 = c(1, 3, 5)
root_age = max(node.depth.edgelength(tree))
grid = expand.grid(sim=1:num_sim, halflife=halflife, theta_1=theta_1,
stv_1=NA, stv_2=NA, sigma2_1=NA, sigma2_2=NA)
grid$theta_2 = -grid$theta_1
grid$alpha = log(2) / grid$halflife
View(grid)
file_in <- paste0(dir_in, "sim_",
i, "/history.Rda")
dir_in = "data/2_simulation/power_sigma2/"
dir_out = "data/2_simulation/power_sigma2/"
file_in <- paste0(dir_in, "sim_",
i, "/history.Rda")
load(file_in)
this_stv = drawStv(linked=T, num_state=num_state)
this_stv = drawStv(linked=T, num_state=num_state)
this_stv
this_stv = drawStv(linked=T, num_state=num_state)
this_stv
# can it be extended to more than 2 states?
stv <- c(runif(1, 0.5*emp, 2*emp))
stv
stv[2] <- stv[1] + rnorm(1, 0, 4)
stv
stv[2] <- stv[1] + rnorm(1, 0, emp)
stv
stv[2] <- stv[1] + rnorm(1, 0, emp)
stv
# can it be extended to more than 2 states?
stv <- c(runif(1, 0.5*emp, 2*emp))
stv
stv[2] <- stv[1] + rnorm(1, 0, emp)
stv
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
rnorm(1, 0, emp)
drawStv <- function(linked, state_dependent, num_state, emp){
#not yet finished
if (isTRUE(linked)){
# can it be extended to more than 2 states?
stv <- c(runif(1, 0.5*emp, 2*emp))
if(num_state == 2){
x <- rnorm(1, 0, emp)
while (stv[1]-abs(x) < 0){
x = rnorm(1, 0, emp)
}
stv[2] <- stv[1] + x
} else {
print(paste("Linked stv only supports binary state currently."))
}
} else {
if(isTRUE(state_dependent)){
stv <- rlnorm(n=num_state, meanlog=log(emp), sdlog=0.587405)
} else {
stv <- rep(rlnorm(n=1, meanlog=log(emp), sdlog=0.587405), num_state)
}
}
names(stv) = c(1:(num_state))
return(stv)
}
this_stv = drawStv(linked=T, num_state=num_state)
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_alpha = c(rep(grid$alpha[i], num_state))
this_alpha
names(this_alpha) = c(1:num_state)
this_sigma2 <- 2 * this_alpha * this_stv
this_sigma2
hist(rnorm(10000, 0, emp))
hist(rnorm(10000, 0, 0.5*emp))
drawStv <- function(linked, state_dependent, num_state, emp){
#not yet finished
if (isTRUE(linked)){
# can it be extended to more than 2 states?
stv <- c(runif(1, 0.5*emp, 2*emp))
if(num_state == 2){
x <- rnorm(1, 0, 0.5*emp)
while (stv[1]-abs(x) < 0){
x = rnorm(1, 0, 0.5*emp)
}
stv[2] <- stv[1] + x
} else {
print(paste("Linked stv only supports binary state currently."))
}
} else {
if(isTRUE(state_dependent)){
stv <- rlnorm(n=num_state, meanlog=log(emp), sdlog=0.587405)
} else {
stv <- rep(rlnorm(n=1, meanlog=log(emp), sdlog=0.587405), num_state)
}
}
names(stv) = c(1:(num_state))
return(stv)
}
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_stv
this_alpha = c(rep(grid$alpha[i], num_state))
names(this_alpha) = c(1:num_state)
this_sigma2 <- 2 * this_alpha * this_stv
this_sigma2
this_theta <- c(grid$theta_1[i], grid$theta_2[i])
names(this_theta) = c(1:num_state)
sim <- simulateContinuous(tree=history, alpha=this_alpha, sigma2=this_sigma2,
theta=this_theta)
sim
this_theta
grid$delta_cont[i] = max(unlist(sim)) - min(unlist(sim))
grid$delta_cont[i]
bar = txtProgressBar(style=3, width=40)
for (i in 1:nrow(grid)){
file_in <- paste0(dir_in, "sim_",
i, "/history.Rda")
load(file_in)
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
this_alpha = c(rep(grid$alpha[i], num_state))
names(this_alpha) = c(1:num_state)
this_sigma2 <- 2 * this_alpha * this_stv
this_theta <- c(grid$theta_1[i], grid$theta_2[i])
names(this_theta) = c(1:num_state)
sim <- simulateContinuous(tree=history, alpha=this_alpha, sigma2=this_sigma2,
theta=this_theta)
grid$delta_cont[i] = max(unlist(sim)) - min(unlist(sim))
this_dir <- paste0(dir_out, "sim_", i)
write.nexus.data(sim, file = paste0(this_dir, "/continuous.nex"),
format="Continuous")
setTxtProgressBar(bar, i / nrow(grid))
}
grid$rho_1 = 1 - ( 1 - exp( -2 * grid$alpha_1 * root_age ) ) / ( 2 * grid$alpha_1 * root_age )
grid$rho_2 = 1 - ( 1 - exp( -2 * grid$alpha_2 * root_age ) ) / ( 2 * grid$alpha_2 * root_age )
grid$rho = 1 - ( 1 - exp( -2 * grid$alpha * root_age ) ) / ( 2 * grid$alpha * root_age )
View(grid)
this_stv[1]
this_stv[[1]]
this_stv[[2]]
grid$stv_1 = this_stv[[1]]
grid$stv_2 = this_stv[[2]]
# simulate continuous traits for power_sigma2
halflife=c(0.1, 0.3, 0.6)
theta_1 = c(1, 3, 5)
root_age = max(node.depth.edgelength(tree))
grid = expand.grid(sim=1:num_sim, halflife=halflife, theta_1=theta_1,
stv_1=NA, stv_2=NA, sigma2_1=NA, sigma2_2=NA)
grid$theta_2 = -grid$theta_1
grid$alpha = log(2) / grid$halflife
grid$rho = 1 - ( 1 - exp( -2 * grid$alpha * root_age ) ) / ( 2 * grid$alpha * root_age )
dir_in = "data/2_simulation/power_sigma2/"
dir_out = "data/2_simulation/power_sigma2/"
bar = txtProgressBar(style=3, width=40)
for (i in 1:nrow(grid)){
file_in <- paste0(dir_in, "sim_",
i, "/history.Rda")
load(file_in)
this_alpha = c(rep(grid$alpha[i], num_state))
names(this_alpha) = c(1:num_state)
this_theta <- c(grid$theta_1[i], grid$theta_2[i])
names(this_theta) = c(1:num_state)
this_stv = drawStv(linked=T, num_state=num_state, emp=emp)
grid$stv_1[i] = this_stv[[1]]
grid$stv_2[i] = this_stv[[2]]
this_sigma2 <- 2 * this_alpha * this_stv
grid$sigma2_1[i] = this_sigma2[[1]]
grid$sigma2_2[i] = this_sigma2[[2]]
sim <- simulateContinuous(tree=history, alpha=this_alpha, sigma2=this_sigma2,
theta=this_theta)
grid$delta_cont[i] = max(unlist(sim)) - min(unlist(sim))
this_dir <- paste0(dir_out, "sim_", i)
write.nexus.data(sim, file = paste0(this_dir, "/continuous.nex"),
format="Continuous")
setTxtProgressBar(bar, i / nrow(grid))
}
write.csv(grid, file="data/2_simulation/power_sigma2/pars.csv")
