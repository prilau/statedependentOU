#layout(matrix(1:4, 2, 2))
#par(mfrow=c(2,2))
pdf(file = "plot2.pdf", width = 8, height = 6)
plot(mod)
step(mod)
vif(mod)
attr <- sort(c("AVG", "avg_hit_angle", "anglesweetspotpercent", "avg_hit_speed", "SO", "p_longhit", "SF_1000", "AB"))
df <- trim[, attr] %>%
as.matrix() %>%
rcorr(type = "spearman") %>%
tidy()
dummy <- data.frame(column1 = attr,
column2 = attr,
estimate = NA,
p.value = NA)
df2 <- df %>%
dplyr::select(-n) %>%
bind_rows(dummy)
attr_labels <- c("Strikeout", "Sacrifice Fly", "% Long Hit", "Average Exit Velocity", "Average Hit Angle", "Batting Average", "% Sweet Spot", "At-bat")
p <- df2 %>%
ggplot(aes(x = column1,
y = column2)) +
geom_tile(aes(fill = estimate)) +
theme_minimal() +
geom_text(aes(label = round(estimate, digits = 2), family = "mono")) +
theme(axis.title = element_blank(),
panel.background = element_blank(),
axis.text = element_text(size = 10,
colour = "#432818",
family = "mono"),
axis.text.x = element_text(angle = 40, hjust=1),
legend.position = "right",
legend.text = element_text(family = "mono"),
axis.ticks = element_blank()) +
scale_fill_gradient2(low = "#fd9e02",
mid = "white",
high = muted("#75b6c6"),
midpoint = 0,
space = "Lab",
na.value = "transparent",
guide = "colourbar",
aesthetics = "fill",
limits=c(-0.5, 0.5),
name = "") +
scale_x_discrete(labels = attr_labels) +
scale_y_discrete(labels = attr_labels)
p
ggsave(filename = "plot2.pdf", device = "pdf",
width = 20, height = 12, units = "cm")
library(patchwork)
mlb <- ((p1/p)) + plot_annotation(tag_levels = "A") + plot_layout(nrow = 2)
ggsave("mlb2.pdf", mlb, device = "pdf")
mlb <- ((p1/p)) + plot_layout(nrow = 2)
ggsave("mlb2.pdf", mlb, device = "pdf")
x = c(6, 8, 10, 12, 14)
y = c(170684,
35369,
13272,
5265,
2838)
plot(x, y)
# simulate the tree
num_tips = 250
tree = ladderize(tess.sim.taxa(1, num_tips, 10, 1, 0.5)[[1]])
setwd("Desktop/ASSIM/lab_hoehna/statedependentOU")
library(TESS)
library(phytools)
source("scripts/readWriteCharacterData.R")
cat("simulating discrete characters.\n")
# simulation parameters
num_tips   = c(100, 250, 500)
#num_states = c(1, 2, 4)
num_traits = 5
reps       = 5
grid = expand.grid(num_tips=num_tips, traits=1:num_traits,
tree=1:reps, stringsAsFactors=FALSE)
grid
grid = expand.grid(num_tips=num_tips, tree=1:reps,
traits=1:num_traits, stringsAsFactors=FALSE)
library(TESS)
cat("simulating trees.\n")
# simulation parameters
num_tips   = c(100, 250, 500)
reps       = 10
grid = expand.grid(num_tips=num_tips, tree=1:reps, stringsAsFactors=FALSE)
# simulate the trees
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips   = this_row[[1]]
this_tree       = this_row[[2]]
# create the directories if necessary
this_dir = paste0("data/n",this_num_tips, "/t", this_tree)
if ( !dir.exists(this_dir) ) {
dir.create(this_dir, recursive=TRUE, showWarnings=FALSE)
}
# simulate the tree
tree = ladderize(tess.sim.taxa(1, this_num_tips, 10, 1, 0.5)[[1]])
# rescale the tree
tree$edge.length = tree$edge.length / max(branching.times(tree))
# write the tree
write.tree(tree, file=paste0(this_dir,"/tree.tre"))
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
cat("\n")
library(TESS)
library(phytools)
source("scripts/readWriteCharacterData.R")
cat("simulating discrete characters.\n")
# simulation parameters
num_tips   = c(100, 250, 500)
#num_states = c(1, 2, 4)
num_traits = 5
reps       = 5
grid = expand.grid(num_tips=num_tips, tree=1:reps,
traits=1:num_traits, stringsAsFactors=FALSE)
# first, we need to compute the tree length of each replicate
tree_lengths = vector("list", length(num_tips))
for(i in 1:length(num_tips)) {
this_dir = paste0("data/n", num_tips[i])
these_files = list.files(this_dir, pattern="tree.tre", recursive=TRUE, full.names = TRUE)
these_trees = lapply(these_files, read.tree)
these_tree_lengths = sapply(these_trees, function(tree) sum(tree$edge.length))
tree_lengths[[i]] = these_tree_lengths
}
mean_tree_lengths = sapply(tree_lengths, mean)
# specify rates so that the expected number of changes is 10
rates = 10 / mean_tree_lengths
names(rates) = num_tips
# specify the Mk2 rate matrix
Q = matrix(1, 2, 2)
diag(Q) = -1
rownames(Q) = colnames(Q) = 1:2 - 1
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="blue","1"="red")
num_rejections = numeric(length(num_tips))
num_simulations = numeric(length(num_tips))
names(num_rejections) = names(num_simulations) = num_tips
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips   = this_row[[1]]
this_tree       = this_row[[2]]
this_num_traits = this_row[[3]]
# read the tree
this_dir = paste0("data/n",this_num_tips, "/t", this_tree)
tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
this_rate = rates[as.character(this_num_tips)]
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (! (mean(history$states == "0") > 0.2 & (mean(history$states == "1") > 0.2) ) ) {
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
num_rejections[as.character(this_num_tips)] = num_rejections[as.character(this_num_tips)] + 1
}
num_simulations[as.character(this_num_tips)] = num_simulations[as.character(this_num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1")]
state_0_tree = tree
state_0_tree$edge.length = maps[,1] / tree$edge.length
state_1_tree = tree
state_1_tree$edge.length = maps[,2] / tree$edge.length
# save these trees
write.tree(state_0_tree, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_State0.tre"))
write.tree(state_1_tree, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_State1.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_Discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_History.Rda"))
# write a pdf
pdf(paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_History.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
grid
reps       = 10
grid = expand.grid(num_tips=num_tips, tree=1:reps,
traits=1:num_traits, stringsAsFactors=FALSE)
nrow(grid)
# first, we need to compute the tree length of each replicate
tree_lengths = vector("list", length(num_tips))
for(i in 1:length(num_tips)) {
this_dir = paste0("data/n", num_tips[i])
these_files = list.files(this_dir, pattern="tree.tre", recursive=TRUE, full.names = TRUE)
these_trees = lapply(these_files, read.tree)
these_tree_lengths = sapply(these_trees, function(tree) sum(tree$edge.length))
tree_lengths[[i]] = these_tree_lengths
}
mean_tree_lengths = sapply(tree_lengths, mean)
# specify rates so that the expected number of changes is 10
rates = 10 / mean_tree_lengths
names(rates) = num_tips
# specify the Mk2 rate matrix
Q = matrix(1, 2, 2)
diag(Q) = -1
rownames(Q) = colnames(Q) = 1:2 - 1
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="blue","1"="red")
num_rejections = numeric(length(num_tips))
num_simulations = numeric(length(num_tips))
names(num_rejections) = names(num_simulations) = num_tips
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips   = this_row[[1]]
this_tree       = this_row[[2]]
this_num_traits = this_row[[3]]
# read the tree
this_dir = paste0("data/n",this_num_tips, "/t", this_tree)
tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
this_rate = rates[as.character(this_num_tips)]
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (! (mean(history$states == "0") > 0.2 & (mean(history$states == "1") > 0.2) ) ) {
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
num_rejections[as.character(this_num_tips)] = num_rejections[as.character(this_num_tips)] + 1
}
num_simulations[as.character(this_num_tips)] = num_simulations[as.character(this_num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1")]
state_0_tree = tree
state_0_tree$edge.length = maps[,1] / tree$edge.length
state_1_tree = tree
state_1_tree$edge.length = maps[,2] / tree$edge.length
# save these trees
write.tree(state_0_tree, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_State0.tre"))
write.tree(state_1_tree, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_State1.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_Discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_History.Rda"))
# write a pdf
pdf(paste0(this_dir, "/n", this_num_tips, "t", this_tree, "k", this_num_traits, "_History.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
library(TESS)
cat("simulating trees.\n")
# simulation parameters
num_tips   = c(100, 250, 500)
reps       = 10
grid = expand.grid(num_tips=num_tips, tree=1:reps, stringsAsFactors=FALSE)
# simulate the trees
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips   = this_row[[1]]
this_tree       = this_row[[2]]
# create the directories if necessary
this_dir = paste0("data/n",this_num_tips, "/t", this_tree)
if ( !dir.exists(this_dir) ) {
dir.create(this_dir, recursive=TRUE, showWarnings=FALSE)
}
# simulate the tree
tree = ladderize(tess.sim.taxa(1, this_num_tips, 10, 1, 0.5)[[1]])
# rescale the tree
tree$edge.length = tree$edge.length / max(branching.times(tree))
# write the tree
write.tree(tree, file=paste0(this_dir,"/tree.tre"))
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
cat("\n")
library(TESS)
library(phytools)
source("scripts/readWriteCharacterData.R")
cat("simulating discrete characters.\n")
# simulation parameters
num_tips   = c(100, 250, 500)
#num_states = c(1, 2, 4)
num_traits = 5
reps       = 10
grid = expand.grid(num_tips=num_tips, tree=1:reps,
traits=1:num_traits, stringsAsFactors=FALSE)
# first, we need to compute the tree length of each replicate
tree_lengths = vector("list", length(num_tips))
for(i in 1:length(num_tips)) {
this_dir = paste0("data/n", num_tips[i])
these_files = list.files(this_dir, pattern="tree.tre", recursive=TRUE, full.names = TRUE)
these_trees = lapply(these_files, read.tree)
these_tree_lengths = sapply(these_trees, function(tree) sum(tree$edge.length))
tree_lengths[[i]] = these_tree_lengths
}
mean_tree_lengths = sapply(tree_lengths, mean)
# specify rates so that the expected number of changes is 10
rates = 10 / mean_tree_lengths
names(rates) = num_tips
# specify the Mk2 rate matrix
Q = matrix(1, 2, 2)
diag(Q) = -1
rownames(Q) = colnames(Q) = 1:2 - 1
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="blue","1"="red")
num_rejections = numeric(length(num_tips))
num_simulations = numeric(length(num_tips))
names(num_rejections) = names(num_simulations) = num_tips
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips   = this_row[[1]]
this_tree       = this_row[[2]]
this_num_traits = this_row[[3]]
# read the tree
this_dir = paste0("data/n",this_num_tips, "/t", this_tree)
tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
this_rate = rates[as.character(this_num_tips)]
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (! (mean(history$states == "0") > 0.2 & (mean(history$states == "1") > 0.2) ) ) {
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
num_rejections[as.character(this_num_tips)] = num_rejections[as.character(this_num_tips)] + 1
}
num_simulations[as.character(this_num_tips)] = num_simulations[as.character(this_num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1")]
state_0_tree = tree
state_0_tree$edge.length = maps[,1] / tree$edge.length
state_1_tree = tree
state_1_tree$edge.length = maps[,2] / tree$edge.length
# save these trees
this_sub_dir = paste0("data/n",this_num_tips, "/t", this_tree, "/d", this_num_traits)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
write.tree(state_0_tree, file=paste0(this_sub_dir, "/n", this_num_tips, "t", this_tree, "d", this_num_traits, "_State0.tre"))
write.tree(state_1_tree, file=paste0(this_sub_dir, "/n", this_num_tips, "t", this_tree, "d", this_num_traits, "_State1.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/n", this_num_tips, "t", this_tree, "d", this_num_traits, "_Discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/n", this_num_tips, "t", this_tree, "d", this_num_traits, "_History.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/n", this_num_tips, "t", this_tree, "d", this_num_traits, "_History.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
cat("\n")
library(ape)
library(phytools)
library(geiger)
library(TESS)
#source("scripts/readWriteCharacterData.R")
# obtain root state
obtainRootState = function(tree) {
edge1d <- rev(postorder(tree))[1]
rootState <- names(history$maps[[edge1d]][1])
rootState <- as.integer(rootState)
return(rootState)
}
treeheight <- function(tree) max(node.depth.edgelength(tree))
obtainContinuousStates_ver7 = function(tree, halflifeRoot, halflifeAlt,
thetaRoot, thetaAlt, stationaryvarRoot,
stationaryvarAlt, initialValue = thetaRoot,
dt = 0.002) {
if (missing(dt)){
dt <- 0.002 * treeheight(history)
}
## Re-parameterization
alphaRoot <- log(2) / halflifeRoot
alphaAlt <- log(2) / halflifeAlt
sigmaRoot <- sqrt(stationaryvarRoot * 2 * alphaRoot)
sigmaAlt <- sqrt(stationaryvarAlt * 2 * alphaAlt)
cont_states <- list()
## obtain root state
root_state <- obtainRootState(tree)
preorder <- rev(postorder(tree))
edges <- tree$edge
ntips <- length(tree$tip.label)
root_node <- ntips + 1
node_values <- list()
node_values[[root_node]] <- initialValue
#for (i in 1:length(branch_order)) {
for (edge_index in preorder){
sub_edges <- tree$maps[[edge_index]]
parent_node <- edges[edge_index, 1]
xt0 <- node_values[[parent_node]]
for (j in 1:length(sub_edges)) {
dt_length = sub_edges[j] %/% dt
dt_remainder = sub_edges[j] %% dt
if (root_state == as.integer(names(sub_edges[j]))) {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt + sigmaRoot * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt_remainder + sigmaRoot * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
else {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt + sigmaAlt * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt_remainder + sigmaAlt * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
}
desc_node <- edges[edge_index, 2]
node_values[[desc_node]] <- xt0
}
disc_states <- list()
for (i in 1:length(edges[,2])) {
is_tip <- !(edges[i,2] %in% edges[,1])
if (is_tip) {
tip_label <- tips(tree, edges[i,2])
cont_states[[tip_label]] <- unname(node_values[[edges[i,2]]])
disc_states[[tip_label]] <- tail(names(history$maps[[i]]), n = 1)
}
}
res <- list(
cont_states,
disc_states
)
return(res)
}
cat("simulating continuous characters.\n")
num_tips   = c(100, 250, 500)
reps       = 10
num_dtraits = 5
num_ctraits = 5
grid = expand.grid(num_tips=num_tips, tree=1:reps,
dtraits=1:num_dtraits, ctraits=1:num_ctraits,
stringsAsFactors=FALSE)
grid
nrow(grid)
bar = txtProgressBar(style=3, width=40)
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips    = this_row[[1]]
this_tree        = this_row[[2]]
this_num_dtraits = this_row[[3]]
this_num_ctraits = this_row[[4]]
# read the history
this_dir = paste0("data/n",this_num_tips, "/t", this_tree, "/d", this_num_dtraits)
load(paste0(this_dir, "/n", this_num_tips,
"t", this_tree, "/d", this_num_dtraits, "_History.Rda"))
cont_states_ver7 <- obtainContinuousStates_ver7(tree = history,
halflifeRoot = 0.35, halflifeAlt = 0.35,
thetaRoot = 0.5, thetaAlt = 2,
stationaryvarRoot = 0.0625, stationaryvarAlt = 0.0625,
initialValue = 0.5, dt = 0.001)
#log_cont_states <- list()
#for (i in 1:length(cont_states_ver7[[1]])) {
#  tiplabel <- names(cont_states_ver7[[1]][i])
#  log_value <- log(as.double(cont_states_ver7[[1]][i]))
#  log_cont_states[[tiplabel]] <- log_value
#}
write.nexus.data(cont_states_ver7[[1]],
file = paste0(this_dir, "/n", this_num_tips,
"t", this_tree, "d", this_num_dtraits,
"c", this_num_ctraits, "_Continuous.nex"),
format="Continuous")
#write.nexus.data(log_cont_states,
#                 file = paste0(this_dir, "/n", this_num_tips,
#                               "t", this_tree, "_logContinuous.nex"),
#                 format="Continuous")
setTxtProgressBar(bar, i / nrow(grid))
}
for(i in 1:nrow(grid)) {
this_row = grid[i,]
this_num_tips    = this_row[[1]]
this_tree        = this_row[[2]]
this_num_dtraits = this_row[[3]]
this_num_ctraits = this_row[[4]]
# read the history
this_dir = paste0("data/n",this_num_tips, "/t", this_tree, "/d", this_num_dtraits)
load(paste0(this_dir, "/n", this_num_tips,
"t", this_tree, "d", this_num_dtraits, "_History.Rda"))
cont_states_ver7 <- obtainContinuousStates_ver7(tree = history,
halflifeRoot = 0.35, halflifeAlt = 0.35,
thetaRoot = 0.5, thetaAlt = 2,
stationaryvarRoot = 0.0625, stationaryvarAlt = 0.0625,
initialValue = 0.5, dt = 0.001)
#log_cont_states <- list()
#for (i in 1:length(cont_states_ver7[[1]])) {
#  tiplabel <- names(cont_states_ver7[[1]][i])
#  log_value <- log(as.double(cont_states_ver7[[1]][i]))
#  log_cont_states[[tiplabel]] <- log_value
#}
write.nexus.data(cont_states_ver7[[1]],
file = paste0(this_dir, "/n", this_num_tips,
"t", this_tree, "d", this_num_dtraits,
"c", this_num_ctraits, "_Continuous.nex"),
format="Continuous")
#write.nexus.data(log_cont_states,
#                 file = paste0(this_dir, "/n", this_num_tips,
#                               "t", this_tree, "_logContinuous.nex"),
#                 format="Continuous")
setTxtProgressBar(bar, i / nrow(grid))
}
