newdata <- mtcars[order(mpg, cyl),]
#sort by mpg (ascending) and cyl (descending)
newdata <- mtcars[order(mpg, -cyl),]
View(newdata)
detach(mtcars)
?ggarrange
library(ggplot2)
library(cowplot)
library(tidyr)
library(dplyr)
library(knitr)
library(jpeg)
library(patchwork)
library(leaflet)
library(tidyverse)
library(readr)
library(broom)
library(car)
library(Hmisc)
library(ggimage)
library(png)
knitr::opts_chunk$set(echo=T,
eval=T,
message = F,
warning=F,
error = F,
cache = F,
tidy = T,
size="footnotesize",
fig.pos='H',
results='hide',
fig.lp='fig:',
fig.align = 'center',
fig.path='figures/example-',
cache.path = 'cache/example-',
tidy.opts=list(width.cutoff=60)
)
library(ggarrange)
???ggarrange
library(patchwork)
library(ggplot2)
library(cowplot)
library(tidyr)
library(dplyr)
library(knitr)
library(jpeg)
library(patchwork)
library(leaflet)
library(tidyverse)
library(readr)
library(broom)
library(car)
library(Hmisc)
library(ggimage)
library(png)
knitr::opts_chunk$set(echo=T,
eval=T,
message = F,
warning=F,
error = F,
cache = F,
tidy = T,
size="footnotesize",
fig.pos='H',
results='hide',
fig.lp='fig:',
fig.align = 'center',
fig.path='figures/example-',
cache.path = 'cache/example-',
tidy.opts=list(width.cutoff=60)
)
players <- read_csv("mlb-player-stats-Batters.csv")
hit <- read_csv("exit_velocity.csv")
comb <- hit %>% mutate(Player = paste0(first_name, " ", last_name)) %>%
inner_join(players, by = "Player")
colnames(comb)
trim <- comb[, -c(1:4, 7, 9:11, 13:18, 20, 22:23, 25, 30:33, 37, 39:41)] %>%
mutate(p_longhit = (`2B`+`3B`+HR)/H,
SF_1000 = 1000*SF/AB)
trim$pos_group <- ifelse(trim$Pos %in% c("1B", "2B", "3B", "SS"), "IF", trim$Pos)
trim <- trim %>%
select(-c(H, `2B`, `3B`, HR, SF, avg_distance)) %>%
select(4, 1:3, 5:12)
group.colors <- c(IF = "#a98467", OF = "#226f54", C ="#da2c38", DH = "#f4f0bb")
level_order <- c('C', '1B', '2B', '3B', 'SS', 'OF', 'DH')
pic <- readJPEG("baseball.jpg", native = T)
p1 <- trim %>%
group_by(pos_group) %>%
ggplot(aes(y = AVG,
x = factor(Pos, level = level_order),
fill = pos_group)) +
geom_boxplot() +
ylab("Batting average") +
xlab("Position") +
ggtitle("Batting average by position") +
scale_fill_manual(values=group.colors) +
theme(axis.text = element_text(size = 10),
legend.position = "none",
plot.title = element_text(hjust = 0.5)) +
inset_element(pic,
left = 0.8,
bottom = 0.6,
right = 1,
top = 1)
library(ggarrange)
mod.1c <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent + avg_hit_speed, trim)
mod.1b <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent , trim)
mod.1a <- lm(AVG ~ avg_hit_angle, trim)
anova(mod.1a, mod.1b, mod.1c)
mod.2c <- lm(AVG ~ avg_hit_speed + avg_hit_angle + anglesweetspotpercent, trim)
mod.2b <- lm(AVG ~ avg_hit_speed + avg_hit_angle , trim)
mod.2a <- lm(AVG ~ avg_hit_speed, trim)
anova(mod.2a, mod.2b, mod.2c)
mod.3c <- lm(AVG ~ anglesweetspotpercent + avg_hit_speed + avg_hit_angle, trim)
mod.3b <- lm(AVG ~ anglesweetspotpercent + avg_hit_speed , trim)
mod.3a <- lm(AVG ~ anglesweetspotpercent, trim)
anova(mod.3a, mod.3b, mod.3c)
mod <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent,
data = trim )
mod <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent,
data = trim )
#layout(matrix(1:4, 2, 2))
#par(mfrow=c(2,2))
pdf(file = "plot2.pdf", width = 8, height = 6)
plot(mod)
step(mod)
vif(mod)
attr <- sort(c("AVG", "avg_hit_angle", "anglesweetspotpercent", "avg_hit_speed", "SO", "p_longhit", "SF_1000", "AB"))
df <- trim[, attr] %>%
as.matrix() %>%
rcorr(type = "spearman") %>%
tidy()
dummy <- data.frame(column1 = attr,
column2 = attr,
estimate = NA,
p.value = NA)
df2 <- df %>%
dplyr::select(-n) %>%
bind_rows(dummy)
attr_labels <- c("Strikeout", "Sacrifice Fly", "% Long Hit", "Average Exit Velocity", "Average Hit Angle", "Batting Average", "% Sweet Spot", "At-bat")
p <- df2 %>%
ggplot(aes(x = column1,
y = column2)) +
geom_tile(aes(fill = estimate)) +
theme_minimal() +
geom_text(aes(label = round(estimate, digits = 2), family = "mono")) +
theme(axis.title = element_blank(),
panel.background = element_blank(),
axis.text = element_text(size = 10,
colour = "#432818",
family = "mono"),
axis.text.x = element_text(angle = 40, hjust=1),
legend.position = "right",
legend.text = element_text(family = "mono"),
axis.ticks = element_blank()) +
scale_fill_gradient2(low = "#fd9e02",
mid = "white",
high = muted("#75b6c6"),
midpoint = 0,
space = "Lab",
na.value = "transparent",
guide = "colourbar",
aesthetics = "fill",
limits=c(-0.5, 0.5),
name = "") +
scale_x_discrete(labels = attr_labels) +
scale_y_discrete(labels = attr_labels)
library(scales)
mod.1c <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent + avg_hit_speed, trim)
mod.1b <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent , trim)
mod.1a <- lm(AVG ~ avg_hit_angle, trim)
anova(mod.1a, mod.1b, mod.1c)
mod.2c <- lm(AVG ~ avg_hit_speed + avg_hit_angle + anglesweetspotpercent, trim)
mod.2b <- lm(AVG ~ avg_hit_speed + avg_hit_angle , trim)
mod.2a <- lm(AVG ~ avg_hit_speed, trim)
anova(mod.2a, mod.2b, mod.2c)
mod.3c <- lm(AVG ~ anglesweetspotpercent + avg_hit_speed + avg_hit_angle, trim)
mod.3b <- lm(AVG ~ anglesweetspotpercent + avg_hit_speed , trim)
mod.3a <- lm(AVG ~ anglesweetspotpercent, trim)
anova(mod.3a, mod.3b, mod.3c)
mod <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent,
data = trim )
mod <- lm(AVG ~ avg_hit_angle + anglesweetspotpercent,
data = trim )
#layout(matrix(1:4, 2, 2))
#par(mfrow=c(2,2))
pdf(file = "plot2.pdf", width = 8, height = 6)
plot(mod)
step(mod)
vif(mod)
attr <- sort(c("AVG", "avg_hit_angle", "anglesweetspotpercent", "avg_hit_speed", "SO", "p_longhit", "SF_1000", "AB"))
df <- trim[, attr] %>%
as.matrix() %>%
rcorr(type = "spearman") %>%
tidy()
dummy <- data.frame(column1 = attr,
column2 = attr,
estimate = NA,
p.value = NA)
df2 <- df %>%
dplyr::select(-n) %>%
bind_rows(dummy)
attr_labels <- c("Strikeout", "Sacrifice Fly", "% Long Hit", "Average Exit Velocity", "Average Hit Angle", "Batting Average", "% Sweet Spot", "At-bat")
p <- df2 %>%
ggplot(aes(x = column1,
y = column2)) +
geom_tile(aes(fill = estimate)) +
theme_minimal() +
geom_text(aes(label = round(estimate, digits = 2), family = "mono")) +
theme(axis.title = element_blank(),
panel.background = element_blank(),
axis.text = element_text(size = 10,
colour = "#432818",
family = "mono"),
axis.text.x = element_text(angle = 40, hjust=1),
legend.position = "right",
legend.text = element_text(family = "mono"),
axis.ticks = element_blank()) +
scale_fill_gradient2(low = "#fd9e02",
mid = "white",
high = muted("#75b6c6"),
midpoint = 0,
space = "Lab",
na.value = "transparent",
guide = "colourbar",
aesthetics = "fill",
limits=c(-0.5, 0.5),
name = "") +
scale_x_discrete(labels = attr_labels) +
scale_y_discrete(labels = attr_labels)
p
ggsave(filename = "plot2.pdf", device = "pdf",
width = 20, height = 12, units = "cm")
library(patchwork)
mlb <- ((p1/p)) + plot_annotation(tag_levels = "A") + plot_layout(nrow = 2)
ggsave("mlb2.pdf", mlb, device = "pdf")
mlb <- ((p1/p)) + plot_layout(nrow = 2)
ggsave("mlb2.pdf", mlb, device = "pdf")
x = c(6, 8, 10, 12, 14)
y = c(170684,
35369,
13272,
5265,
2838)
plot(x, y)
setwd("Desktop/ASSIM/lab_hoehna/statedependentOU/")
?log
library(ape)
#library(nodiv)
library(phytools)
library(geiger)
library(TESS)
source("scripts/readWriteCharacterData.R")
# simulate the tree
num_tips = 250
tree = ladderize(tess.sim.taxa(1, num_tips, 10, 1, 0.5)[[1]])
# rescale the tree
tree$edge.length = tree$edge.length / max(branching.times(tree))
write.tree(tree, file=paste0("data/n250_simulation.tre"))
tree_lengths <- sum(tree$edge.length)
# specify rates so that the expected number of changes is 5
rates = 10 / tree_lengths
names(rates) = num_tips
# specify the Mk2 rate matrix
Q = matrix(1, 2, 2)
diag(Q) = -1
rownames(Q) = colnames(Q) = 1:2 - 1
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="blue","1"="red")
num_rejections = numeric(length(num_tips))
num_simulations = numeric(length(num_tips))
names(num_rejections) = names(num_simulations) = num_tips
this_rate = rates[as.character(num_tips)]
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
while (! (mean(history$states == "0") > 0.2 & (mean(history$states == "1") > 0.2) ) ) {
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
maps = history$mapped.edge[,c("0","1")]
pdf("data/n250History.pdf")
plot(history, col=colors)
dev.off()
writeCharacterData(t(t(history$states)), file=paste0("data/n250_simulationDiscrete.nex"), type="Standard")
# obtain root state
obtainRootState = function(tree) {
edge1d <- rev(postorder(tree))[1]
rootState <- names(history$maps[[edge1d]][1])
rootState <- as.integer(rootState)
return(rootState)
}
obtainRootState(tree)
treeheight <- function(tree) max(node.depth.edgelength(tree))
obtainContinuousStates_ver7 = function(tree, halflifeRoot, halflifeAlt,
thetaRoot, thetaAlt, sigmaRoot, sigmaAlt,
initialValue = thetaRoot, dt = 0.002) {
if (missing(dt)){
dt <- 0.002 * treeheight(history)
}
## Re-parameterization
alphaRoot <- log(2) / halflifeRoot
alphaAlt <- log(2) / halflifeAlt
cont_states <- list()
## obtain root state
root_state <- obtainRootState(tree)
preorder <- rev(postorder(tree))
edges <- tree$edge
ntips <- length(tree$tip.label)
root_node <- ntips + 1
node_values <- list()
node_values[[root_node]] <- initialValue
#for (i in 1:length(branch_order)) {
for (edge_index in preorder){
sub_edges <- tree$maps[[edge_index]]
parent_node <- edges[edge_index, 1]
xt0 <- node_values[[parent_node]]
for (j in 1:length(sub_edges)) {
dt_length = sub_edges[j] %/% dt
dt_remainder = sub_edges[j] %% dt
if (root_state == as.integer(names(sub_edges[j]))) {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt + sigmaRoot * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt_remainder + sigmaRoot * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
else {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt + sigmaAlt * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt_remainder + sigmaAlt * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
}
desc_node <- edges[edge_index, 2]
node_values[[desc_node]] <- xt0
}
disc_states <- list()
for (i in 1:length(edges[,2])) {
is_tip <- !(edges[i,2] %in% edges[,1])
if (is_tip) {
tip_label <- tips(tree, edges[i,2])
cont_states[[tip_label]] <- unname(node_values[[edges[i,2]]])
disc_states[[tip_label]] <- tail(names(history$maps[[i]]), n = 1)
}
}
res <- list(
cont_states,
disc_states
)
return(res)
}
plot(history)
cont_states_ver7 <- obtainContinuousStates_ver7(tree = history,
halflifeRoot = 0.35, halflifeAlt = 0.35,
thetaRoot = 50, thetaAlt = 20,
sigmaRoot = 5, sigmaAlt = 5,
initialValue = 50, dt = 0.001)
View(cont_states_ver7)
par(mar = c(6,7,3,3))
hist(as.numeric(cont_states_ver7), xlab = "tip character values", ylab = "frequency")
hist(as.numeric(cont_states_ver7[[1]]), xlab = "tip character values", ylab = "frequency")
library(slouch)
install.packages("slouch")
library(slouch)
df <- data.frame(
"species" = names(cont_states_ver7[[1]]),
"y" = as.numeric(cont_states_ver7[[1]]),
"regime" = unname(unlist(cont_states_ver7[[2]]))
)
df <- df[match(history$tip.label, df$species), ]
?slouch.fit
m0 <- slouch.fit(
history,
hl_values = seq(0.05, 0.25, length.out = 35),
sigma2_y_values = seq(35, 65, length.out = 35),
response = df$y,
species = df$species,
fixed.fact = df$regime,
anc_maps = "simmap",
hillclimb = F
)
m0 <- slouch.fit(
history,
hl_values = seq(0.05, 0.25, length.out = 35),
sigma2_y_values = seq(35, 65, length.out = 35),
response = df$y,
species = df$species,
fixed.fact = df$regime,
#anc_maps = "simmap",
hillclimb = F
)
write.nexus.data(cont_states_ver7[[1]], file = "data/n250_simulationContinuous.nex", format = "continuous")
var(unlist(cont_states_ver7[[1]]))
# simulate the tree
num_tips = 100
tree = ladderize(tess.sim.taxa(1, num_tips, 10, 1, 0.5)[[1]])
# rescale the tree
tree$edge.length = tree$edge.length / max(branching.times(tree))
write.tree(tree, file=paste0("data/n100_simulation.tre"))
tree_lengths <- sum(tree$edge.length)
# specify rates so that the expected number of changes is 5
rates = 10 / tree_lengths
names(rates) = num_tips
# specify the Mk2 rate matrix
Q = matrix(1, 2, 2)
diag(Q) = -1
rownames(Q) = colnames(Q) = 1:2 - 1
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="blue","1"="red")
num_rejections = numeric(length(num_tips))
num_simulations = numeric(length(num_tips))
names(num_rejections) = names(num_simulations) = num_tips
this_rate = rates[as.character(num_tips)]
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
while (! (mean(history$states == "0") > 0.2 & (mean(history$states == "1") > 0.2) ) ) {
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
maps = history$mapped.edge[,c("0","1")]
pdf("data/n100History.pdf")
plot(history, col=colors)
dev.off()
writeCharacterData(t(t(history$states)), file=paste0("data/n100_simulationDiscrete.nex"), type="Standard")
# obtain root state
obtainRootState = function(tree) {
edge1d <- rev(postorder(tree))[1]
rootState <- names(history$maps[[edge1d]][1])
rootState <- as.integer(rootState)
return(rootState)
}
obtainRootState(tree)
treeheight <- function(tree) max(node.depth.edgelength(tree))
obtainContinuousStates_ver7 = function(tree, halflifeRoot, halflifeAlt,
thetaRoot, thetaAlt, sigmaRoot, sigmaAlt,
initialValue = thetaRoot, dt = 0.002) {
if (missing(dt)){
dt <- 0.002 * treeheight(history)
}
## Re-parameterization
alphaRoot <- log(2) / halflifeRoot
alphaAlt <- log(2) / halflifeAlt
cont_states <- list()
## obtain root state
root_state <- obtainRootState(tree)
preorder <- rev(postorder(tree))
edges <- tree$edge
ntips <- length(tree$tip.label)
root_node <- ntips + 1
node_values <- list()
node_values[[root_node]] <- initialValue
#for (i in 1:length(branch_order)) {
for (edge_index in preorder){
sub_edges <- tree$maps[[edge_index]]
parent_node <- edges[edge_index, 1]
xt0 <- node_values[[parent_node]]
for (j in 1:length(sub_edges)) {
dt_length = sub_edges[j] %/% dt
dt_remainder = sub_edges[j] %% dt
if (root_state == as.integer(names(sub_edges[j]))) {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt + sigmaRoot * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaRoot * (thetaRoot - xt0) * dt_remainder + sigmaRoot * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
else {
for (k in 1:dt_length) {
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt + sigmaAlt * sqrt(dt) * rnorm(1)
xt0 <- xt1
}
xt1 <- xt0 + alphaAlt * (thetaAlt - xt0) * dt_remainder + sigmaAlt * sqrt(dt_remainder) * rnorm(1)
xt0 <- xt1
}
}
desc_node <- edges[edge_index, 2]
node_values[[desc_node]] <- xt0
}
disc_states <- list()
for (i in 1:length(edges[,2])) {
is_tip <- !(edges[i,2] %in% edges[,1])
if (is_tip) {
tip_label <- tips(tree, edges[i,2])
cont_states[[tip_label]] <- unname(node_values[[edges[i,2]]])
disc_states[[tip_label]] <- tail(names(history$maps[[i]]), n = 1)
}
}
res <- list(
cont_states,
disc_states
)
return(res)
}
plot(history)
cont_states_ver7 <- obtainContinuousStates_ver7(tree = history,
halflifeRoot = 0.35, halflifeAlt = 0.35,
thetaRoot = 50, thetaAlt = 20,
sigmaRoot = 5, sigmaAlt = 5,
initialValue = 50, dt = 0.001)
par(mar = c(6,7,3,3))
hist(as.numeric(cont_states_ver7[[1]]), xlab = "tip character values", ylab = "frequency")
treeheight(history)
write.nexus.data(cont_states_ver7[[1]], file = "data/n100_simulationContinuous.nex", format = "continuous")
var(unlist(cont_states_ver7[[1]]))
