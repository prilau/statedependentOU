log_nf_right = 0
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
log_nf_right = log_nf_right + sub_bl_right[[i]] * α[[state]]
}
contrast = mean_left - mean_right
a = -(contrast*contrast / (2*(var_left+var_right)))
b = log(2*pi*(var_left+var_right))/2.0
#b = log(2*pi)/2.0 + log(var_left+var_right)/2.0
log_nf = log_nf_left + log_nf_right + a - b
log_norm_factor[node_index] = log_nf
return(list(μ, V, log_norm_factor))
# if is internal node
if (node_index > ntip){
left_edge  = which(edge[,1] == node_index)[1] # index of left child edge
right_edge = which(edge[,1] == node_index)[2] # index of right child edge
left = edge[left_edge,2] # index of left child node
right = edge[right_edge,2] # index of right child node
output_left <- sd_postorder(left, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output_left[[1]]
V <- output_left[[2]]
log_norm_factor <- output_left[[3]]
output_right <- sd_postorder(right, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output_right[[1]]
V <- output_right[[2]]
log_norm_factor <- output_right[[3]]
sub_bl_left = subedges_lengths[[left_edge]] # all subedges of left child edge
sub_bl_right = subedges_lengths[[right_edge]] # all subedges of right child edge
# for the sake of readability, computation of variance, mean, and log_nf are done in separate loops
# 1) variance of the normal variable: this branch (v_left) and the subtree (V[left])
## Is 'delta_left* exp(2.0 * α * bl_left)' added in each sub-edge?
delta_left = V[left]
v_left = 0 # initialise v_left
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
v_left = σ2[[state]]/(2*α[[state]]) *expm1(2.0*α[[state]]
*sub_bl_left[[i]])
delta_left = v_left + delta_left * exp(2.0 * α[[state]] * sub_bl_left[[i]])
}
delta_right = V[right]
v_right = 0 # initialise v_right
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
v_right = σ2[[state]]/(2*α[[state]]) *expm1(2.0*α[[state]]*sub_bl_right[[i]])
delta_right = v_right + delta_right * exp(2.0 * α[[state]] * sub_bl_right[[i]])
}
var_left = delta_left
var_right = delta_right
# 2) mean of the normal variable
mean_left = μ[left]
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
mean_left = exp(α[[state]]*sub_bl_left[[i]])*(mean_left - θ[[state]]) + θ[[state]]
}
mean_right = μ[right]
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
mean_right = exp(α[[state]]*sub_bl_right[[i]])*(mean_right - θ[[state]]) + θ[[state]]
}
## compute the mean and variance of the node
mean_ancestor = (mean_left * var_right + mean_right * var_left) / (var_left + var_right)
μ[node_index] = mean_ancestor
var_node = (var_left * var_right) / (var_left + var_right)
V[node_index] = var_node
## compute the normalizing factor, the left-hand side of the pdf of the normal variable
## this is the problem. I think in RevBayes we compute log_nf with the oldest sub-edge only
log_nf_left = 0
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
log_nf_left = log_nf_left + sub_bl_left[[i]] * α[[state]]
}
log_nf_right = 0
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
log_nf_right = log_nf_right + sub_bl_right[[i]] * α[[state]]
}
contrast = mean_left - mean_right
a = -(contrast*contrast / (2*(var_left+var_right)))
b = log(2*pi*(var_left+var_right))/2.0
#b = log(2*pi)/2.0 + log(var_left+var_right)/2.0
log_nf = log_nf_left + log_nf_right + a - b
log_norm_factor[node_index] = log_nf
return(list(μ, V, log_norm_factor))
}
sd_postorder <- function(node_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ){
ntip = length(tree$tip.label)
# if is internal node
if (node_index > ntip){
left_edge  = which(edge[,1] == node_index)[1] # index of left child edge
right_edge = which(edge[,1] == node_index)[2] # index of right child edge
left = edge[left_edge,2] # index of left child node
right = edge[right_edge,2] # index of right child node
output_left <- sd_postorder(left, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output_left[[1]]
V <- output_left[[2]]
log_norm_factor <- output_left[[3]]
output_right <- sd_postorder(right, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output_right[[1]]
V <- output_right[[2]]
log_norm_factor <- output_right[[3]]
sub_bl_left = subedges_lengths[[left_edge]] # all subedges of left child edge
sub_bl_right = subedges_lengths[[right_edge]] # all subedges of right child edge
# for the sake of readability, computation of variance, mean, and log_nf are done in separate loops
# 1) variance of the normal variable: this branch (v_left) and the subtree (V[left])
## Is 'delta_left* exp(2.0 * α * bl_left)' added in each sub-edge?
delta_left = V[left]
v_left = 0 # initialise v_left
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
v_left = σ2[[state]]/(2*α[[state]]) *expm1(2.0*α[[state]]
*sub_bl_left[[i]])
delta_left = v_left + delta_left * exp(2.0 * α[[state]] * sub_bl_left[[i]])
}
delta_right = V[right]
v_right = 0 # initialise v_right
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
v_right = σ2[[state]]/(2*α[[state]]) *expm1(2.0*α[[state]]*sub_bl_right[[i]])
delta_right = v_right + delta_right * exp(2.0 * α[[state]] * sub_bl_right[[i]])
}
var_left = delta_left
var_right = delta_right
# 2) mean of the normal variable
mean_left = μ[left]
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
mean_left = exp(α[[state]]*sub_bl_left[[i]])*(mean_left - θ[[state]]) + θ[[state]]
}
mean_right = μ[right]
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
mean_right = exp(α[[state]]*sub_bl_right[[i]])*(mean_right - θ[[state]]) + θ[[state]]
}
## compute the mean and variance of the node
mean_ancestor = (mean_left * var_right + mean_right * var_left) / (var_left + var_right)
μ[node_index] = mean_ancestor
var_node = (var_left * var_right) / (var_left + var_right)
V[node_index] = var_node
## compute the normalizing factor, the left-hand side of the pdf of the normal variable
## this is the problem. I think in RevBayes we compute log_nf with the oldest sub-edge only
log_nf_left = 0
for (i in rev(1:length(sub_bl_left))){
state <- names(sub_bl_left[i])
log_nf_left = log_nf_left + sub_bl_left[[i]] * α[[state]]
}
log_nf_right = 0
for (i in rev(1:length(sub_bl_right))){
state <- names(sub_bl_right[i])
log_nf_right = log_nf_right + sub_bl_right[[i]] * α[[state]]
}
contrast = mean_left - mean_right
a = -(contrast*contrast / (2*(var_left+var_right)))
b = log(2*pi*(var_left+var_right))/2.0
#b = log(2*pi)/2.0 + log(var_left+var_right)/2.0
log_nf = log_nf_left + log_nf_right + a - b
log_norm_factor[node_index] = log_nf
return(list(μ, V, log_norm_factor))
}
# if is tip
else{
species = tree$tip.label[node_index]
μ[node_index] = as.numeric(continuousChar[[which(names(continuousChar) == species)]])
V[node_index] = 0.0 ## if there is no observation error
return(list(μ, V, log_norm_factor))
}
}
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
ntip = length(tree$tip.label) # number of tips
edge = tree$edge # equals tree[:edge] in Julia
n_edges = length(edge[,1]) # number of edges
max_node_index = max(tree$edge) # total number of nodes
V = numeric(max_node_index)
μ = numeric(max_node_index)
log_norm_factor = numeric(max_node_index)
subedges_lengths = tree$maps
root_index = ntip + 1
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output[[1]]
V <- output[[2]]
log_norm_factor <- output[[3]]
V
μ
log_norm_factor <- output[[3]]
log_norm_factor
root_index
## assume root value equal to theta
μ_root = μ[root_index]
v_root = V[root_index]
left_edge_from_root <- which(edge[,1] == ntip+1)[1] # obtain left child edge index of root node
left_edge_from_root
left_edge_from_root <- which(edge[,1] == root_index)[1] # obtain left child edge index of root node
left_edge_from_root
left_subedges_from_root <- subedges_lengths[left_edge_from_root] # obtain sub-edge lengths
left_subedges_from_root
names(tail(left_subedges_from_root, 1))
head(left_subedges_from_root, 1)
left_subedges_from_root
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
left_subedges_from_root
### note here
root_state = names(head(left_subedges_from_root, 1)) # obtain root state, assuming it equals last state at left child edge
root_state
lnl = dnorm(θ[[root_state]], mean = μ_root, sd = sqrt(v_root), log = TRUE)
lnl
## add norm factor
for (log_nf in log_norm_factor){
lnl = lnl + log_nf
}
lnl
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
sd_logL_pruning <- function(tree, continuousChar, σ2, α, θ){
ntip = length(tree$tip.label) # number of tips
edge = tree$edge # equals tree[:edge] in Julia
n_edges = length(edge[,1]) # number of edges
max_node_index = max(tree$edge) # total number of nodes
V = numeric(max_node_index)
μ = numeric(max_node_index)
log_norm_factor = numeric(max_node_index)
subedges_lengths = tree$maps
root_index = ntip + 1
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output[[1]]
V <- output[[2]]
log_norm_factor <- output[[3]]
## assume root value equal to theta
μ_root = μ[root_index]
v_root = V[root_index]
left_edge_from_root <- which(edge[,1] == root_index)[1] # obtain left child edge index of root node
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
### note here
root_state = names(head(left_subedges_from_root, 1)) # obtain root state, assuming it equals last state at left child edge
lnl = dnorm(θ[[root_state]], mean = μ_root, sd = sqrt(v_root), log = TRUE)
## add norm factor
for (log_nf in log_norm_factor){
lnl = lnl + log_nf
}
return(lnl)
}
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# RUN
sd_logL_vcv(smaptree, brain, named_α, named_σ2, named_θ)
named_α <- named_alpha
named_σ2 <- named_sigma2
named_θ <- named_theta
# RUN
sd_logL_vcv(smaptree, brain, named_α, named_σ2, named_θ)
# RUN
logL_vcv(tree, brain, named_sigma2[[1]], named_alpha[[1]], named_theta[[1]])
named_sigma2
named_alpha
named_theta
named_α
named_θ
RUN
named_σ2
named_sigma2
named_alpha
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
named_theta
sd_logL_pruning <- function(tree, continuousChar, σ2, α, θ){
ntip = length(tree$tip.label) # number of tips
edge = tree$edge # equals tree[:edge] in Julia
n_edges = length(edge[,1]) # number of edges
max_node_index = max(tree$edge) # total number of nodes
V = numeric(max_node_index)
μ = numeric(max_node_index)
log_norm_factor = numeric(max_node_index)
subedges_lengths = tree$maps
root_index = ntip + 1
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output[[1]]
V <- output[[2]]
log_norm_factor <- output[[3]]
## assume root value equal to theta
μ_root = μ[root_index]
v_root = V[root_index]
left_edge_from_root <- which(edge[,1] == root_index)[1] # obtain left child edge index of root node
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
### note here
root_state = names(tail(left_subedges_from_root, 1)) # obtain root state, assuming it equals last state at left child edge
lnl = dnorm(θ[[root_state]], mean = μ_root, sd = sqrt(v_root), log = TRUE)
## add norm factor
for (log_nf in log_norm_factor){
lnl = lnl + log_nf
}
return(lnl)
}
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# RUN
sd_logL_vcv(smaptree, brain, named_α, named_σ2, named_θ)
named_sigma2
named_sigma2[[1:3]]
named_sigma2[[1,3]]
named_sigma2[[1]] = 2
named_sigma2[[2]] = 2
named_sigma2[[3]] = 2
named_σ2 <- named_sigma2
named_sigma2
named_θ
named_θ[[1]] <- 5
named_θ[[1]] <- 6
named_θ[[2]] <- 6
named_θ[[3]] <- 6
named_theta <- named_θ
named_theta
named_α[[1]] <- 1
named_α[[2]] <- 1
named_α[[3]] <- 1
named_alpha <- named_α
named_alpha
# RUN
sd_logL_vcv(smaptree, brain, named_α, named_σ2, named_θ)
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# From slouch
data("artiodactyla")
# RUN
logL_vcv(tree, brain, named_sigma2[[1]], named_alpha[[1]], named_theta[[1]])
logL_pruning(smaptree, brain, σ2 = 2, α = 1, θ = 6)
left_subedges_from_root
which(edge[,1] == root_index)[2]
subedges_lengths[[2]]
sd_logL_pruning <- function(tree, continuousChar, σ2, α, θ){
ntip = length(tree$tip.label) # number of tips
edge = tree$edge # equals tree[:edge] in Julia
n_edges = length(edge[,1]) # number of edges
max_node_index = max(tree$edge) # total number of nodes
V = numeric(max_node_index)
μ = numeric(max_node_index)
log_norm_factor = numeric(max_node_index)
subedges_lengths = tree$maps
root_index = ntip + 1
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, σ2, α, θ)
μ <- output[[1]]
V <- output[[2]]
log_norm_factor <- output[[3]]
## assume root value equal to theta
μ_root = μ[root_index]
v_root = V[root_index]
left_edge_from_root <- which(edge[,1] == root_index)[1] # obtain left child edge index of root node
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
### note here
root_state = names(head(left_subedges_from_root, 1)) # obtain root state, assuming it equals last state at left child edge
lnl = dnorm(θ[[root_state]], mean = μ_root, sd = sqrt(v_root), log = TRUE)
## add norm factor
for (log_nf in log_norm_factor){
lnl = lnl + log_nf
}
return(lnl)
}
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
named_theta[[1]]
named_theta[[1]] <- 7
# RUN
sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
named_theta[[1]] <- 6
# option 2: match parameter values and discrete states in one line
named_alpha <- c("MF" = 1.1, "Gr" = 1.2, "Br" = 1.3)
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# RUN
sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
named_alpha[[1]] <- 1
named_alpha[[2]] <- 1
named_alpha[[3]] <- 1
named_theta <- c("MF" = 6.1, "Gr" = 6.2, "Br" = 6.3)
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# RUN
sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
named_theta <- c("MF" = 6, "Gr" = 6, "Br" = 6)
named_sigma2 <- c(2.1, 2.2, 2.3)
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
named_sigma2 <- c(2.1, 2.2, 2.3)
names(named_sigma2) <- discrete_states
###################################################
#                                                 #
#       Guideline for sd_logL_pruning()           #
#                                                 #
###################################################
sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# RUN
sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
named_sigma2 <- c(2, 2, 2)
# RUN
sdvcv_brain <- sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
named_sigma2 <- c(2.1, 2.2, 2.3)
names(named_sigma2) <- discrete_states
named_sigma2 <- c(2, 2, 2)
names(named_sigma2) <- discrete_states
# RUN
sdvcv_brain <- sd_logL_vcv(smaptree, brain, named_alpha, named_sigma2, named_theta)
sdpruning_brain <- sd_logL_pruning(smaptree, brain, σ2 = named_sigma2, α = named_alpha, θ = named_theta)
# From local
dummy_tree <- read.simmap("data/1_validation/dummy_threetaxon_simmap.tre",
format="phylip",version=1)
# read.nexus.data() gives lists of species with character values, need to change to input format for our functions
char <- read.nexus.data("data/1_validation/dummy_threetaxon_Continuous.nex")
continuousChar <- c()
for (species in char){
continuousChar <- append(continuousChar, as.numeric(species))
}
names(continuousChar) <- names(char)
continuousChar
plot(dummy_tree)
tree <- dummy_tree
ntip = length(tree$tip.label) # number of tips
edge = tree$edge # equals tree[:edge] in Julia
n_edges = length(edge[,1]) # number of edges
max_node_index = max(tree$edge) # total number of nodes
V = numeric(max_node_index)
μ = numeric(max_node_index)
log_norm_factor = numeric(max_node_index)
V
subedges_lengths = tree$maps
subedges_lengths
root_index = ntip + 1
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, sigma2, alpha, theta)
sigma2 <- c("1" = 1.1, "2" = 1.2, "3" = 1.3)
alpha <- c("1" = 2.1, "2" = 2.2, "3" = 2.3)
theta <- c("1" = 6.1, "2" = 6.2, "3" = 6.3)
output <- sd_postorder(root_index, edge, tree, continuousChar,
μ, V, log_norm_factor, subedges_lengths, sigma2, alpha, theta)
output
μ <- output[[1]]
V <- output[[2]]
log_norm_factor <- output[[3]]
## assume root value equal to theta
μ_root = μ[root_index]
v_root = V[root_index]
left_edge_from_root <- which(edge[,1] == root_index)[1] # obtain left child edge index of root node
left_edge_from_root
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
left_subedges_from_root
left_subedges_from_root <- subedges_lengths[[left_edge_from_root]] # obtain sub-edge lengths
### note here
root_state = names(head(left_subedges_from_root, 1)) # obtain root state, assuming it equals last state at left child edge
root_state
lnl = dnorm(theta[[root_state]], mean = μ_root, sd = sqrt(v_root), log = TRUE)
lnl
## add norm factor
for (log_nf in log_norm_factor){
lnl = lnl + log_nf
}
lnl
ntip <- length(tree$tip.label)
V = vcv.matrix(tree, named_alpha, named_sigma2)
V
named_alpha = alpha
named_sigma2 = sigma2
named_theta = theta
V = vcv.matrix(tree, named_alpha, named_sigma2)
V
W = weight.matrix(tree, named_alpha)
W
named_alpha
C = chol(V) # upper triangular matrix
C
L = t(C) # lower triangular matrix
L
log_det_V = 0
for (i in 1:ntip){
log_det_V = log_det_V + log(L[i,i])
}
log_det_V = log_det_V * 2.0 # equals to julia implementation to 12 sig. fig.
y = NULL
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
y
# inverse of L
r = solve(L) %*% y - solve(L) %*% W %*% named_theta # what does de-correlated residuals mean?
r
# res = - (n/2) * log(2*pi) - 0.5 * log_det_V - 0.5 * dot(r, r)
#     = exp(-n/2)^(2*pi) * exp(-0.5)^det_V * exp(-0.5)^dot(r, r) ?
res = 0.0
res = res - (ntip/2) * log(2*pi)
res = res - 0.5 * log_det_V
res = res - 0.5 * dot(r, r) # is it dot product? what is dot product of r?
