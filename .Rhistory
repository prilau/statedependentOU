# track the number of rejected simulations based on proportional
# representation
colors = c("0"="#44aa99", "1"="#ddcc77", "2"="#882255")
bar = txtProgressBar(style=3, width=40)
for(i in 4:(num_sim+3)) {
#this_row = grid[i,]
#this_model   = this_row[[1]]
#this_tree       = this_row[[2]]
# read the tree
#this_dir = paste0("data/2_simulation/", this_model, "/t", this_tree)
#tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
#this_rate = rates[as.character(this_model)]
#this_rate = rates
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (! (mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
#num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
#if ( !dir.exists(this_sub_dir) ) {
#  dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
#}
#
#write.tree(state_0_tree, file=paste0(this_sub_dir, "/state0.tre"))
#write.tree(state_1_tree, file=paste0(this_sub_dir, "/state1.tre"))
#write.tree(state_2_tree, file=paste0(this_sub_dir, "/state2.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
for(i in 4:(num_sim+3)) {
#this_row = grid[i,]
#this_model   = this_row[[1]]
#this_tree       = this_row[[2]]
# read the tree
#this_dir = paste0("data/2_simulation/", this_model, "/t", this_tree)
#tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
#this_rate = rates[as.character(this_model)]
#this_rate = rates
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (! (mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
#num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
#write.tree(state_0_tree, file=paste0(this_sub_dir, "/state0.tre"))
#write.tree(state_1_tree, file=paste0(this_sub_dir, "/state1.tre"))
#write.tree(state_2_tree, file=paste0(this_sub_dir, "/state2.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
for(i in 4:(num_sim+3)) {
#this_row = grid[i,]
#this_model   = this_row[[1]]
#this_tree       = this_row[[2]]
# read the tree
#this_dir = paste0("data/2_simulation/", this_model, "/t", this_tree)
#tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
#this_rate = rates[as.character(this_model)]
#this_rate = rates
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (!(mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
#num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
#write.tree(state_0_tree, file=paste0(this_sub_dir, "/state0.tre"))
#write.tree(state_1_tree, file=paste0(this_sub_dir, "/state1.tre"))
#write.tree(state_2_tree, file=paste0(this_sub_dir, "/state2.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
cat("\n")
for(i in 4:(num_sim+3)) {
#this_row = grid[i,]
#this_model   = this_row[[1]]
#this_tree       = this_row[[2]]
# read the tree
#this_dir = paste0("data/2_simulation/", this_model, "/t", this_tree)
#tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
#this_rate = rates[as.character(this_model)]
#this_rate = rates
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (isFALSE(mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
#num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
#write.tree(state_0_tree, file=paste0(this_sub_dir, "/state0.tre"))
#write.tree(state_1_tree, file=paste0(this_sub_dir, "/state1.tre"))
#write.tree(state_2_tree, file=paste0(this_sub_dir, "/state2.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
setTxtProgressBar(bar, i / nrow(grid))
}
i=4
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (isFALSE(mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
# make sure at least 20% of the tips are in either state
while (!(mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# simulate the discrete characters
# track the number of rejected simulations based on proportional
# representation
colors = c("0"="#44aa99", "1"="#ddcc77", "2"="#882255")
for(i in 4:(num_sim+3)) {
#this_row = grid[i,]
#this_model   = this_row[[1]]
#this_tree       = this_row[[2]]
# read the tree
#this_dir = paste0("data/2_simulation/", this_model, "/t", this_tree)
#tree = read.tree(paste0(this_dir, "/tree.tre"))
# get the rate
#this_rate = rates[as.character(this_model)]
#this_rate = rates
# simulate the character
history = sim.history(tree, this_rate * Q, nsim=1, message=FALSE)
# make sure at least 20% of the tips are in either state
while (!(mean(history$states == "0") > 0.10 & mean(history$states == "1") > 0.10 & mean(history$states == "2") > 0.10) ) {
history = sim.history(tree, rate * Q, nsim=1, message=FALSE)
#num_rejections[as.character(num_tips)] = num_rejections[as.character(num_tips)] + 1
}
#num_simulations[as.character(num_tips)] = num_simulations[as.character(num_tips)] + 1
# make state-0 and state-1 trees
# the branch length of state-i trees is the proportional
# amount of time each branch spends in state i
maps = history$mapped.edge[,c("0","1","2")]
#state_0_tree = tree
#state_0_tree$edge.length = maps[,1] / tree$edge.length
#
#state_1_tree = tree
#state_1_tree$edge.length = maps[,2] / tree$edge.length
#
#state_2_tree = tree
#state_2_tree$edge.length = maps[,3] / tree$edge.length
#
## save these trees
this_sub_dir = paste0("data/2_simulation/convergence/sim_", i)
if ( !dir.exists(this_sub_dir) ) {
dir.create(this_sub_dir, recursive=TRUE, showWarnings=FALSE)
}
#write.tree(state_0_tree, file=paste0(this_sub_dir, "/state0.tre"))
#write.tree(state_1_tree, file=paste0(this_sub_dir, "/state1.tre"))
#write.tree(state_2_tree, file=paste0(this_sub_dir, "/state2.tre"))
# save the discrete trait as a nexus file
writeCharacterData(t(t(history$states)), file=paste0(this_sub_dir, "/discrete.nex"), type="Standard")
# save the character history
save(history, file=paste0(this_sub_dir, "/history.Rda"))
# write a pdf
pdf(paste0(this_sub_dir, "/history.pdf"))
plot(history, col=colors)
dev.off()
# increment the progress bar
#setTxtProgressBar(bar, i / nrow(grid))
}
library(ape)
library(phytools)
library(geiger)
library(TESS)
library(tidyverse)
drawHalflife <- function(state_dependent=T){
if(state_dependent == T){
halflife <- rlnorm(n=3, meanlog=4.349757, sdlog=1.044495)
names(halflife) = sample(c("0", "1", "2"))
} else {
halflife <- rep(rlnorm(n=1, meanlog=4.349757, sdlog=1.044495), 3)
names(halflife) = c("0", "1", "2")
}
return(halflife)
}
drawStv <- function(state_dependent=T){
if(state_dependent == T){
stv <- rlnorm(n=3, meanlog=log(12.39783716), sdlog=0.587405)
names(stv) = sample(c("0", "1", "2"))
} else {
stv <- rep(rlnorm(n=1, meanlog=log(12.39783716), sdlog=0.587405), 3)
names(stv) = c("0", "1", "2")
}
return(stv)
}
drawTheta <- function(state_dependent=T){
if(state_dependent == T){
theta <- c(runif(n=3, -10, 10))
} else {
theta <- rep(runif(n=1, -10, 10), 3)
}
names(theta) = c("0", "1", "2")
return(theta)
}
simulateContinuous = function(tree, stateDependencies=c(halflife=T, stv=T, theta=T)) {
## Re-parameterization
#alpha <- log(2) / halflife
#sigma2 <- stationaryvar * 2 * alpha
if (isTRUE(stateDependencies["halflife"])){
halflife <-  drawHalflife(state_dependent = T)
} else {
halflife <-  drawHalflife(state_dependent = F)
}
if (isTRUE(stateDependencies["stv"])){
stv <-  drawStv(state_dependent = T)
} else {
stv <-  drawStv(state_dependent = F)
}
if (isTRUE(stateDependencies["theta"])){
theta <-  drawTheta(state_dependent = T)
} else {
theta <-  drawTheta(state_dependent = F)
}
alpha <- log(2) / halflife
sigma2 <- 2 * alpha * stv
preorder <- rev(postorder(tree))
edges <- tree$edge
root_node <- length(tree$tip.label) + 1
state = tree$node.states[root_node]
mu_at_nodes <- rep(0, length(tree$node.states))
mu_at_nodes[root_node] <- theta[[state]]
#draw root state
#alpha_root <- drawAlpha(state_dependent = stateDependencies[1])[[state]]
#sigma2_root <- drawAlpha(state_dependent = stateDependencies[2])[[state]]
#theta_root <- drawTheta(state_dependent = stateDependencies[3])[[state]]
#mu_at_nodes[root_node] <- drawRootState(alpha_root, sigma2_root, theta_root)
#if (rootState == "optimum"){
#  mu_at_nodes[root_node] <- theta[[state]]
#} else if (rootState == "equilibrium") {
#  mu_at_nodes[root_node] <- rnorm(1, mean = theta[[state]],
#                                  sd = sqrt(sigma2[[state]]/(2*alpha[[state]])))
#} else if (rootState == "parameter"){
#  mu_at_nodes[root_node] <- runif(1, min = min(theta)/2, max = max(theta)*2)
#}
for (edge_index in preorder){
sub_edges <- tree$maps[[edge_index]]
parent_node <- edges[edge_index, 1]
y <- mu_at_nodes[parent_node]
for (j in 1:length(sub_edges)) {
#alpha <- drawAlpha(state_dependent = stateDependencies[1])
#sigma2 <- drawAlpha(state_dependent = stateDependencies[2])
#theta <- drawAlpha(state_dependent = stateDependencies[3])
state <- names(sub_edges[j])
mu <- y * exp(-alpha[[state]] * sub_edges[[j]]) + theta[[state]] * (1 - exp(-alpha[[state]] * sub_edges[[j]]))
v <- sigma2[[state]] / (2 * alpha[[state]]) * (1 - exp(-2 * alpha[[state]] * sub_edges[[j]]))
y <- rnorm(n=1, mu, sqrt(v))
}
desc_node <- edges[edge_index, 2]
mu_at_nodes[desc_node] <- y
}
cont_list <- list()
for (i in 1:length(tree$tip.label)){
tip <- tree$tip.label[i]
cont_list[[tip]] <- mu_at_nodes[i]
}
return(list(cont_list, alpha, sigma2, theta))
}
pars_3state_sd <- tibble(alpha_0 = 0,  alpha_1 = 0, alpha_2 = 0,
sigma2_0 = 0, sigma2_1 = 0, sigma2_2 = 0,
theta_0 = 0,  theta_1 = 0, theta_2 = 0)
#pars_3state_stateless <- tibble(alpha_0 = 0,  alpha_1 = 0,
#                         sigma2_0 = 0, sigma2_1 = 0,
#                         theta_0 = 0,  theta_1 = 0)
#sim = vector("list", length = 50)
for (i in 4:8){
filename <- paste0("data/2_simulation/convergence/sim_",
i, "/history.Rda")
load(filename)
sim_sd <- simulateContinuous(history, c(halflife=T, stv=T, theta=T))
#sim_stateless <- simulateContinuous(history, c(halflife=F, stv=F, theta=F))
pars_3state_sd[i,1] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "0")])
pars_3state_sd[i,2] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "1")])
pars_3state_sd[i,3] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "2")])
pars_3state_sd[i,4] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "0")])
pars_3state_sd[i,5] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "1")])
pars_3state_sd[i,6] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "2")])
pars_3state_sd[i,7] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "0")])
pars_3state_sd[i,8] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "1")])
pars_3state_sd[i,9] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "2")])
#pars_3state_stateless[i,1] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "0")])
#pars_3state_stateless[i,2] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "1")])
#pars_3state_stateless[i,3] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "2")])
#pars_3state_stateless[i,4] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "0")])
#pars_3state_stateless[i,5] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "1")])
#pars_3state_stateless[i,6] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "2")])
#pars_3state_stateless[i,7] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "0")])
#pars_3state_stateless[i,8] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "1")])
#pars_3state_stateless[i,9] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "2")])
this_dir <- paste0("data/2_simulation/convergence/sim_", i)
write.nexus.data(sim_sd[[1]], file = paste0(this_dir, "/continuous_sd.nex"),
format="Continuous")
#write.nexus.data(sim_stateless[[1]], file = paste0(this_dir, "/continuous_stateless.nex"),
#                 format="Continuous")
}
i
filename <- paste0("data/2_simulation/convergence/sim_",
i, "/history.Rda")
load(filename)
sim_sd <- simulateContinuous(history, c(halflife=T, stv=T, theta=T))
pars_3state_sd
#sim_stateless <- simulateContinuous(history, c(halflife=F, stv=F, theta=F))
pars_3state_sd[i,1] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "0")])
unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "0")])
i=1
filename <- paste0("data/2_simulation/convergence/sim_",
i+3, "/history.Rda")
load(filename)
sim_sd <- simulateContinuous(history, c(halflife=T, stv=T, theta=T))
#sim_stateless <- simulateContinuous(history, c(halflife=F, stv=F, theta=F))
pars_3state_sd[i,1] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "0")])
#pars_3state_stateless <- tibble(alpha_0 = 0,  alpha_1 = 0,
#                         sigma2_0 = 0, sigma2_1 = 0,
#                         theta_0 = 0,  theta_1 = 0)
#sim = vector("list", length = 50)
for (i in 1:5){
filename <- paste0("data/2_simulation/convergence/sim_",
i+3, "/history.Rda")
load(filename)
sim_sd <- simulateContinuous(history, c(halflife=T, stv=T, theta=T))
#sim_stateless <- simulateContinuous(history, c(halflife=F, stv=F, theta=F))
pars_3state_sd[i,1] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "0")])
pars_3state_sd[i,2] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "1")])
pars_3state_sd[i,3] <- unname(sim_sd[[2]][which(names(sim_sd[[2]]) == "2")])
pars_3state_sd[i,4] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "0")])
pars_3state_sd[i,5] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "1")])
pars_3state_sd[i,6] <- unname(sim_sd[[3]][which(names(sim_sd[[3]]) == "2")])
pars_3state_sd[i,7] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "0")])
pars_3state_sd[i,8] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "1")])
pars_3state_sd[i,9] <- unname(sim_sd[[4]][which(names(sim_sd[[4]]) == "2")])
#pars_3state_stateless[i,1] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "0")])
#pars_3state_stateless[i,2] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "1")])
#pars_3state_stateless[i,3] <- unname(sim_stateless[[2]][which(names(sim_stateless[[2]]) == "2")])
#pars_3state_stateless[i,4] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "0")])
#pars_3state_stateless[i,5] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "1")])
#pars_3state_stateless[i,6] <- unname(sim_stateless[[3]][which(names(sim_stateless[[3]]) == "2")])
#pars_3state_stateless[i,7] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "0")])
#pars_3state_stateless[i,8] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "1")])
#pars_3state_stateless[i,9] <- unname(sim_stateless[[4]][which(names(sim_stateless[[4]]) == "2")])
this_dir <- paste0("data/2_simulation/convergence/sim_", i+3)
write.nexus.data(sim_sd[[1]], file = paste0(this_dir, "/continuous_sd.nex"),
format="Continuous")
#write.nexus.data(sim_stateless[[1]], file = paste0(this_dir, "/continuous_stateless.nex"),
#                 format="Continuous")
}
pars_sd <- pars_sd %>%
mutate(halflife_0 = log(2) / alpha_0,
halflife_1 = log(2) / alpha_1,
halflife_2 = log(2) / alpha_2,
stv_0 = sigma2_0 / (2 * alpha_0),
stv_1 = sigma2_1 / (2 * alpha_1),
stv_2 = sigma2_2 / (2 * alpha_2),
rho_0 = 1 - ( 1 - exp( -2 * alpha_0 * root_age ) ) / ( 2 * alpha_0 * root_age ),
rho_1 = 1 - ( 1 - exp( -2 * alpha_1 * root_age ) ) / ( 2 * alpha_1 * root_age ),
rho_2 = 1 - ( 1 - exp( -2 * alpha_2 * root_age ) ) / ( 2 * alpha_2 * root_age ))
root_age <- max(node.depth.edgelength(history))
pars_3state_sd <- pars_3state_sd %>%
mutate(halflife_0 = log(2) / alpha_0,
halflife_1 = log(2) / alpha_1,
halflife_2 = log(2) / alpha_2,
stv_0 = sigma2_0 / (2 * alpha_0),
stv_1 = sigma2_1 / (2 * alpha_1),
stv_2 = sigma2_2 / (2 * alpha_2),
rho_0 = 1 - ( 1 - exp( -2 * alpha_0 * root_age ) ) / ( 2 * alpha_0 * root_age ),
rho_1 = 1 - ( 1 - exp( -2 * alpha_1 * root_age ) ) / ( 2 * alpha_1 * root_age ),
rho_2 = 1 - ( 1 - exp( -2 * alpha_2 * root_age ) ) / ( 2 * alpha_2 * root_age ))
#pars_3state_stateless <- pars_stateless %>%
#  mutate(halflife_0 = log(2) / alpha_0,
#         halflife_1 = log(2) / alpha_1,
#         halflife_2 = log(2) / alpha_2,
#         stv_0 = sigma2_0 / (2 * alpha_0),
#         stv_1 = sigma2_1 / (2 * alpha_1),
#         stv_2 = sigma2_2 / (2 * alpha_2),
#         rho_0 = 1 - ( 1 - exp( -2 * alpha_0 * root_age ) ) / ( 2 * alpha_0 * root_age ),
#         rho_1 = 1 - ( 1 - exp( -2 * alpha_1 * root_age ) ) / ( 2 * alpha_1 * root_age ),
#         rho_2 = 1 - ( 1 - exp( -2 * alpha_2 * root_age ) ) / ( 2 * alpha_2 * root_age ))
save(pars_3state_sd, file="data/2_simulation/convergence/pars_3state_sd.Rda")
