}
k1
k2 <- parentNode(tree, x2)
k2
k1[which(mcra_node)]
x2
x2 <- parentNode(tree, x2)
x2
mcra_node <- x2
k1[which(mcra_node)]
k1[which(mcra_node == TRUE)]
k1[which(k1 == mcra_node)]
which(k1 == mcra_node)
after_diverge_index <- which(k1 == mcra_node) - 1
after_diverge_index
common_nodes <- tail(k1, n = -after_diverge_index)
common_nodes
x1 = 1
x2 =2
k1 <- x1
k2 <- x2
N <- length(tree$tip.label)
while(x1 != N + 1){
k1 <- c(k1, parentNode(tree, x1))
x1 <- tail(k1, n = 1)
}
while(x2 != N + 1 && x2 %!in% k1){
x2 <- parentNode(tree, x2)
if (x2 %in% k1){
mcra_node <- x2
}
}
while(x2 != N + 1 && x2 !%in% k1){
!%in%
while(x2 != N + 1 && !(x2 %in% k1)){
x2 <- parentNode(tree, x2)
if (x2 %in% k1){
mcra_node <- x2
}
}
mcra_node
after_diverge_index <- which(k1 == mcra_node) - 1
common_nodes <- tail(k1, n = -after_diverge_index)
common_nodes
named_sigma2
time_point <- cumsum(c(0, unname(subedge_lengths))) # tip
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
nodesBeforeDiverge <- function(tree, x1, x2){
k1 <- x1
k2 <- x2
N <- length(tree$tip.label)
while(x1 != N + 1){
k1 <- c(k1, parentNode(tree, x1))
x1 <- tail(k1, n = 1)
}
while(x2 != N + 1 && !(x2 %in% k1)){
x2 <- parentNode(tree, x2)
if (x2 %in% k1){
mcra_node <- x2
}
}
after_diverge_index <- which(k1 == mcra_node) - 1
common_nodes <- tail(k1, n = -after_diverge_index)
return(common_nodes)
}
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
nodes
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
edges
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
subedge_lengths
times <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
time_point <- cumsum(c(0, unname(subedge_lengths))) # tip
time_point
ape::mrca(tree)[tip1, tip2]
k <- ape::mrca(tree)[tip1, tip2]
k
x <- k
while(x != N + 1){
k <- c(x, parentNode(tree, k))
x <- tail(k, n = 1)
}
k
x
nodesBeforeDiverge <- function(tree, tip1, tip2){
k <- ape::mrca(tree)[tip1, tip2]
x <- k
common_nodes <- c()
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(x, parentNode(tree, k))
x <- tail(k, n = 1)
}
return(k)
}
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
nodes
?ape::node.depth.edgelength
ape::node.depth.edgelength(tree)
mcra_time <- ape::node.depth.edgelength(tree)[nodes[1]]
mcra_time
times <- ape::node.depth.edgelength(tree) # get time at each node from root
times
max(age_root0tip1)
age_root0tip1 <- ape::node.depth.edgelength(tree)
max(age_root0tip1)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
mcra_time
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
time_point
time_begin <- c(tail(time_point, n = -1)) ## older end of subedge
time_begin
class(time_begin)
time_end <- c(head(time_point, n = -1)) ## younger end of subedge
time_end
times$time_begin <- time_begin
times$time_end <- time_end
time_begin
time_end
times$time_begin <- time_begin
times
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
times <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
times$time_span
times <- tibble(time_span = unname(subedge_lengths),
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
age_root0tip1 <- ape::node.depth.edgelength(tree)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_end) - exp(2 * alpha * time_begin))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_end) - exp(2 * alpha * time_begin)))
named_alpha[[1]] = 1.1
named_alpha[[2]] = 1.2
named_sigma2[[1]] = 2.1
named_sigma2[[2]] = 2.2
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
age_root0tip1 <- ape::node.depth.edgelength(tree)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
sum1 <- times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_end) - exp(2 * alpha * time_begin))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
sum1
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
v.sum2 <- function(tree, tip, named_alpha){
nodes <- nodesAlongLineage(tree, tip)
#nodes1 <- output[[1]]
#nodes_common <- output[[3]]
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)])
#edges_common <- which(tree$edge[,2] %in% nodes_common) # from tip to root
#subedge_lengths_common <- rev(unlist(lapply(edges_common, function(i) tree$maps[[i]])))
sum2 <- subedge_lengths %>%
mutate(sum2 = time_span * alpha) %>%
reframe(sum = sum(sum2)) %>%
unlist() %>%
unname()
return(sum2)
}
v.sum1 <- function(tree, tip1, tip2, named_alpha, named_sigma2){
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
age_root0tip1 <- ape::node.depth.edgelength(tree)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
sum1 <- times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_end) - exp(2 * alpha * time_begin))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
}
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
exp2
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
sum1
v_ij <- exp2 * sum1
v_ij
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
sum1
times %>% mutate(exp = exp(2 * alpha * time_end))
times %>% mutate(exp = exp(2 * alpha * time_begin))
vcv.pairwise <- function(tree, named_alpha, named_sigma2, tip1, tip2){
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
v_ij <- exp2 * sum1
return(v_ij)
}
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, nrow = ntip)
V <- matrix(nrow = ntip, ncol = ntip)
V
c(1:j, j+1:ntip)
j = ntip
c(1:j, j+1:ntip)
c(1:j-1, j+1:ntip)
ntip
c(1:ntip)
while (j != 0){
for (i in 1:ntip){
if (i = j){
while (j != 0){
for (i in 1:ntip){
if (i == j){
V[i,j] = 0
}
else{
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
}
V
vcv.pairwise(tree, named_alpha, named_sigma2, 3, 1)
tip1 <- 3
tip2 <- 2
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
v_ij <- exp2 * sum1
v_ij
sum2_tip1
sum2_tip2
exp2
sum1
# test with slouch data set
# compare stateless_vcv and stateless_pruning
data("artiodactyla")
data("neocortex")
artiodactyla
vcv.matrix <- function(tree, named_alpha, named_sigma2, tip1, tip2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
if (i == j){
V[i,j] = 0
}
else{
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
}
}
V = vcv.matrix(tree, named_alpha, named_sigma2, tip1, tip2)
W = weight.matrix(tree, named_alpha)
W
C = chol(V) # upper triangular matrix
V
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
if (i == j){
V[i,j] = 0
}
else{
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
}
}
V = vcv.matrix(tree, named_alpha, named_sigma2)
V
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
if (i == j){
V[i,j] = 0
}
else{
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
}
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
if (i == j){
V[i,j] = 0
}
else{
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
}
return(V)
}
V = vcv.matrix(tree, named_alpha, named_sigma2)
V
C = chol(V) # upper triangular matrix
v.sum1 <- function(tree, tip1, tip2, named_alpha, named_sigma2){
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
age_root0tip1 <- ape::node.depth.edgelength(tree)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
sum1 <- times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
}
# not yet finished - weight matrix function
weights.lineage <- function(tree, named_alpha, e){
lineage <- lineage.constructor(tree, e)
lineage[["alpha"]] = named_alpha[lineage[["state_changes"]]]
lineage <- lineage %>% mutate(exp_1 = exp(-alpha * time_begin) - exp(-alpha * time_end),
exp_2 = alpha * lineage$time_span)
ancestral_state <- lineage$state_changes[length(lineage$state_changes)]
weight_ancestral = lineage %>%
summarise(ancestral = exp(-1 * sum(exp_2))) %>%
unlist()
names(weight_ancestral) <- ancestral_state
weights <- lineage %>%
group_by(state_changes) %>%
summarise(weight = sum(exp_1) * exp(-1 * sum(exp_2)))
weights$weight[which(weights$state_changes == ancestral_state)] = weights$weight[which(weights$state_changes == ancestral_state)] + weight_ancestral
#weight_states <- weights$weight
#names(weight_states) <- weights$state_changes
#weight_states[which(names(weight_states) == ancestral_state)] = weight_states[which(names(weight_states) == ancestral_state)] + weight_ancestral
#weight_matrix = weight_matrix / sum(weight_matrix)
weight_matrix <- matrix(nrow = length(named_alpha))
rownames(weight_matrix) <- c(names(named_alpha))
for (rowname in rownames(weight_matrix)){
if (rowname %in% weights$state_changes){
weight_matrix[rowname,] = weights$weight[which(weights$state_changes == rowname)]
}
else {
weight_matrix[rowname,] = 0
}
}
# normalise the weights so that sum(weights) == 1
weight_matrix = weight_matrix/sum(weight_matrix)
return(weight_matrix)
}
weights.lineage(tree, named_alpha, 1)
# not yet finished - weight matrix function
weights.lineage <- function(tree, named_alpha, e){
lineage <- lineage.constructor(tree, e)
lineage[["alpha"]] = named_alpha[lineage[["state_changes"]]]
lineage <- lineage %>% mutate(exp_1 = exp(-alpha * time_end) - exp(-alpha * time_begin),
exp_2 = alpha * lineage$time_span)
ancestral_state <- lineage$state_changes[length(lineage$state_changes)]
weight_ancestral = lineage %>%
summarise(ancestral = exp(-1 * sum(exp_2))) %>%
unlist()
names(weight_ancestral) <- ancestral_state
weights <- lineage %>%
group_by(state_changes) %>%
summarise(weight = sum(exp_1) * exp(-1 * sum(exp_2)))
weights$weight[which(weights$state_changes == ancestral_state)] = weights$weight[which(weights$state_changes == ancestral_state)] + weight_ancestral
#weight_states <- weights$weight
#names(weight_states) <- weights$state_changes
#weight_states[which(names(weight_states) == ancestral_state)] = weight_states[which(names(weight_states) == ancestral_state)] + weight_ancestral
#weight_matrix = weight_matrix / sum(weight_matrix)
weight_matrix <- matrix(nrow = length(named_alpha))
rownames(weight_matrix) <- c(names(named_alpha))
for (rowname in rownames(weight_matrix)){
if (rowname %in% weights$state_changes){
weight_matrix[rowname,] = weights$weight[which(weights$state_changes == rowname)]
}
else {
weight_matrix[rowname,] = 0
}
}
# normalise the weights so that sum(weights) == 1
weight_matrix = weight_matrix/sum(weight_matrix)
return(weight_matrix)
}
}
## issues:
## values should be non-negative!!
##
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
}
j = j-1
return(V)
}
V = vcv.matrix(tree, named_alpha, named_sigma2)
## issues:
## values should be non-negative!!
##
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
return(V)
}
V = vcv.matrix(tree, named_alpha, named_sigma2)
V
C = chol(V) # upper triangular matrix
V
# α has to be named
sd_logL_vcv <- function(tree, continuousChar, named_alpha, named_sigma2, named_theta){
V = vcv.matrix(tree, named_alpha, named_sigma2)
W = weight.matrix(tree, named_alpha)
C = chol(V) # upper triangular matrix
L = t(C) # lower triangular matrix
log_det_V = 0
for (i in 1:ntip){
log_det_V = log_det_V + log(L[i,i])
}
log_det_V = log_det_V * 2.0 # equals to julia implementation to 12 sig. fig.
y = NULL
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
# inverse of L
r = solve(L) %*% y - solve(L) %*% W * θ # what does de-correlated residuals mean?
# res = - (n/2) * log(2*pi) - 0.5 * log_det_V - 0.5 * dot(r, r)
#     = exp(-n/2)^(2*pi) * exp(-0.5)^det_V * exp(-0.5)^dot(r, r) ?
res = 0.0
res = res - (ntip/2) * log(2*pi)
res = res - 0.5 * log_det_V
res = res - 0.5 * dot(r, r) # is it dot product? what is dot product of r?
return(res)
}
