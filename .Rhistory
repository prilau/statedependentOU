names(alpha) <- c("0", "1", "2")
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = alpha[names(subedge_lengths)])
subedge_lengths
for (i in 1:1000){
tree <- alltrees[[i]]
#root_state[i] <- names(tree$maps[[1]][1])
alpha <- c()
sigma2 <- c()
theta <- c()
alpha[1] <- metadata$alpha_Br[i]
alpha[2] <- metadata$alpha_Gr[i]
alpha[3] <- metadata$alpha_MF[i]
sigma2[1] <- metadata$sigma2_Br[i]
sigma2[2] <- metadata$sigma2_Gr[i]
sigma2[3] <- metadata$sigma2_MF[i]
theta[1] <- metadata$theta_Br[i]
theta[2] <- metadata$theta_Gr[i]
theta[3] <- metadata$theta_MF[i]
names(alpha) <- c("0", "1", "2")
names(sigma2) <- c("0", "1", "2")
names(theta) <- c("0", "1", "2")
#logL$R_pruning[i] <- sd_logL_pruning(tree, brain, alpha, sigma2, theta)
logL$R_vcv[i] <- sd_logL_pruning(tree, brain, alpha, sigma2, theta)
}
for (i in 1:1000){
tree <- alltrees[[i]]
#root_state[i] <- names(tree$maps[[1]][1])
alpha <- c()
sigma2 <- c()
theta <- c()
alpha[1] <- metadata$alpha_Br[i]
alpha[2] <- metadata$alpha_Gr[i]
alpha[3] <- metadata$alpha_MF[i]
sigma2[1] <- metadata$sigma2_Br[i]
sigma2[2] <- metadata$sigma2_Gr[i]
sigma2[3] <- metadata$sigma2_MF[i]
theta[1] <- metadata$theta_Br[i]
theta[2] <- metadata$theta_Gr[i]
theta[3] <- metadata$theta_MF[i]
names(alpha) <- c("0", "1", "2")
names(sigma2) <- c("0", "1", "2")
names(theta) <- c("0", "1", "2")
#logL$R_pruning[i] <- sd_logL_pruning(tree, brain, alpha, sigma2, theta)
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
}
i
tree <- alltrees[[i]]
#root_state[i] <- names(tree$maps[[1]][1])
alpha <- c()
sigma2 <- c()
theta <- c()
alpha[1] <- metadata$alpha_Br[i]
alpha[2] <- metadata$alpha_Gr[i]
alpha[3] <- metadata$alpha_MF[i]
sigma2[1] <- metadata$sigma2_Br[i]
sigma2[2] <- metadata$sigma2_Gr[i]
sigma2[3] <- metadata$sigma2_MF[i]
theta[1] <- metadata$theta_Br[i]
theta[2] <- metadata$theta_Gr[i]
theta[3] <- metadata$theta_MF[i]
names(alpha) <- c("0", "1", "2")
names(sigma2) <- c("0", "1", "2")
names(theta) <- c("0", "1", "2")
alpha = alpha[sort(names(alpha))]
sigma2 = sigma2[sort(names(sigma2))]
theta = theta[sort(names(theta))]
theta = as.matrix(theta, nrow = 3)
alpha
ntip <- length(tree$tip.label)
tree <- alltrees[[2]]
ntip <- length(tree$tip.label)
V = vcv.matrix(tree, alpha, sigma2)
W = weight.matrix(tree, alpha)
ntip = length(tree$tip.label)
weight_matrix = matrix(0, nrow = ntip, ncol = length(alpha))
rownames(weight_matrix) <- tree$tip.label
colnames(weight_matrix) <- c(sort(names(alpha)))
for (i in 1:ntip){
weight_matrix[i, ] <- weights.lineage(tree, alpha, i)
}
i
weights.lineage(tree, alpha, 1)
weights.lineage(tree, alpha, 2)
root_node = length(tree$tip.label) + 1
e=1
lineage <- lineage.constructor(tree, root_node, e)
lineage
lineage[["alpha"]] = alpha[lineage[["state"]]]
lineage
W = matrix(0, ncol = length(alpha), nrow = 1)
colnames(W) = sort(names(alpha))
weights$state[1]
weights
root_node = length(tree$tip.label) + 1
lineage <- lineage.constructor(tree, root_node, e)
lineage[["alpha"]] = alpha[lineage[["state"]]]
W = matrix(0, ncol = length(alpha), nrow = 1)
colnames(W) = sort(names(alpha))
W[, all_weights$state[1]] = 1
W[, lineage$state[1]] = 1
W
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
# not yet finished - weight matrix function
## need updates
weights.lineage <- function(tree, alpha, e){
root_node = length(tree$tip.label) + 1
lineage <- lineage.constructor(tree, root_node, e)
lineage[["alpha"]] = alpha[lineage[["state"]]]
W = matrix(0, ncol = length(alpha), nrow = 1)
colnames(W) = sort(names(alpha))
if (length(lineage[[1]]) > 1){
lineage <- lineage %>%
mutate(
exp1 = -1 * expm1(-1 * alpha * time_span),
sum2_temp = -1 * alpha * time_span)
lineage$exp1[length(lineage$exp1)] = 1
lineage$sum2 = 0
for (i in 2:length(lineage[[1]])){
lineage$sum2[i] = lineage$sum2_temp[i-1]
lineage$sum2_temp[i] = lineage$sum2[i] + lineage$sum2_temp[i]
}
all_weights = lineage %>% mutate(exp_final = exp1 * exp(sum2)) %>%
group_by(state) %>%
summarise(weight = sum(exp_final))
for (i in 1:nrow(all_weights)){
W[, all_weights$state[i]] = all_weights$weight[i]
}
} else {
W[, lineage$state[1]] = 1
}
return(W)
}
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, alpha, sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
colnames(V) <- tree$tip.label
rownames(V) <- tree$tip.label
ntip = length(tree$tip.label)
weight_matrix = matrix(0, nrow = ntip, ncol = length(alpha))
rownames(weight_matrix) <- tree$tip.label
colnames(weight_matrix) <- c(sort(names(alpha)))
for (i in 1:ntip){
weight_matrix[i, ] <- weights.lineage(tree, alpha, i)
}
weight_matrix
W <- weight_matrix
View(W)
C = chol(V) # upper triangular matrix
L = t(C) # lower triangular matrix
log_det_V = 0
for (i in 1:ntip){
log_det_V = log_det_V + log(L[i,i])
}
log_det_V = log_det_V * 2.0 # equals to julia implementation to 12 sig. fig.
y = NULL
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
continuousChar = brain
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
y
solve(L) %*% y
solve(L) %*% W %*% theta
solve(L) %*% y - solve(L) %*% W %*% theta
# find parent node by providing child node
parentNode <- function(tree, x){
m <- which(tree$edge[, 2] == x)
return(tree$edge[m, 1])
}
# find nodes along a lineage towards root node by providing initial child (presumably tip) node
nodesAlongLineage <- function(tree, old_node, young_node){
k <- young_node
while(young_node != old_node){
k <- c(k, parentNode(tree, young_node))
young_node <- tail(k, n = 1)
}
return(k)
}
# find subedges of a lineage
lineage.constructor <- function(tree, root_node, e){
nodes <- nodesAlongLineage(tree, root_node, e)
edges <- which(tree$edge[,2] %in% nodes) # from root to tip
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # tip to root
state_changes <- names(subedge_lengths) # from tip to root
#state_changes <- c(state_changes[1], state_changes) # add root state, assuming root state equals the state of the closest subedge
#lineage$state_indicator <- lapply(all_states, function(x) {res <- match(lineage$state_changes, x); res[is.na(res)] <- 0; return(res)})
#names(lineage$state_indicator) <- all_states
# recording time-related numbers of each subedge (root is a subedge with length = 0)
#times <- cumsum(unname(subedge_lengths))
#time_tip <- tail(times, n = 1)
#time_begin <- time_tip - c(0, head(times, n = -1))
#time_end <- time_tip - times
#time_span <- time_begin - time_end
return(tibble(state = state_changes,
#time_begin = time_begin,
#time_end = time_end,
time_span = subedge_lengths))
}
# not yet finished - weight matrix function
## need updates
weights.lineage <- function(tree, alpha, e){
root_node = length(tree$tip.label) + 1
lineage <- lineage.constructor(tree, root_node, e)
lineage[["alpha"]] = alpha[lineage[["state"]]]
W = matrix(0, ncol = length(alpha), nrow = 1)
colnames(W) = sort(names(alpha))
if (length(lineage[[1]]) > 1){
lineage <- lineage %>%
mutate(
exp1 = -1 * expm1(-1 * alpha * time_span),
sum2_temp = -1 * alpha * time_span)
lineage$exp1[length(lineage$exp1)] = 1
lineage$sum2 = 0
for (i in 2:length(lineage[[1]])){
lineage$sum2[i] = lineage$sum2_temp[i-1]
lineage$sum2_temp[i] = lineage$sum2[i] + lineage$sum2_temp[i]
}
all_weights = lineage %>% mutate(exp_final = exp1 * exp(sum2)) %>%
group_by(state) %>%
summarise(weight = sum(exp_final))
for (i in 1:nrow(all_weights)){
W[, all_weights$state[i]] = all_weights$weight[i]
}
} else {
W[, lineage$state[1]] = 1
}
return(W)
}
# combine to form weight matrix
weight.matrix <- function(tree, alpha){
ntip = length(tree$tip.label)
weight_matrix = matrix(0, nrow = ntip, ncol = length(alpha))
rownames(weight_matrix) <- tree$tip.label
colnames(weight_matrix) <- c(sort(names(alpha)))
for (i in 1:ntip){
weight_matrix[i, ] <- weights.lineage(tree, alpha, i)
}
return(weight_matrix)
}
cov.accum <- function(tree, mrca_node, alpha, sigma2){
root_node = length(tree$tip.label) + 1
if (mrca_node == root_node){
cov_accum = 0.0
} else {
nodes <- nodesAlongLineage(tree, root_node, mrca_node)
edges <- which(tree$edge[,2] %in% nodes) # from root to mcra_node
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from mcra_node to root
subedge_lengths <- tibble(state = names(subedge_lengths),
time_span = subedge_lengths,
alpha = alpha[names(subedge_lengths)],
sigma2 = sigma2[names(subedge_lengths)]) %>%
mutate(exp1 = -1 * expm1(-2 * alpha * time_span),
sum2_temp = -2 * alpha * time_span)
subedge_lengths$sum2= 0
if (length(subedge_lengths[[1]]) == 1){
subedge_lengths = subedge_lengths %>%
mutate(cov = sigma2 / (2 * alpha) * exp1)
cov_accum = subedge_lengths$cov[[1]]
} else {
for (i in 2:length(subedge_lengths[[1]])){
subedge_lengths$sum2[i] = subedge_lengths$sum2_temp[i-1]
subedge_lengths$sum2_temp[i] = subedge_lengths$sum2[i] + subedge_lengths$sum2_temp[i]
}
cov_accum = subedge_lengths %>% mutate(exp3 = exp1 * exp(sum2)) %>%
group_by(state) %>%
summarise(sum4 = sum(sigma2 / (2 * alpha) * exp3)) %>%
reframe(sum_final = sum(sum4)) %>%
unlist() %>%
unname()
}
}
return(cov_accum)
}
cov.loss <- function(tree, mrca_node, alpha, tip){
if (mrca_node == tip){
cov_loss_rate = 0
} else {
nodes <- nodesAlongLineage(tree, mrca_node, tip)
nodes <- head(nodes, n = -1)
edges <- which(tree$edge[,2] %in% nodes) # from root to mcra_node
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from mcra_node to root
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = alpha[names(subedge_lengths)])
cov_loss_rate = subedge_lengths %>%
mutate(sum1 = -1 * alpha * time_span) %>%
reframe(sum_final = sum(sum1))
}
return(cov_loss_rate)
}
vcv.pairwise <- function(tree, alpha, sigma2, tip1, tip2){
mrca_node <- ape::mrca(tree)[tip1, tip2]
cov_accum = cov.accum(tree, mrca_node, alpha, sigma2)
cov_loss1 = cov.loss(tree, mrca_node, alpha, tip1)
cov_loss2 = cov.loss(tree, mrca_node, alpha, tip2)
cov = cov_accum * exp(cov_loss1 + cov_loss2)
return(unlist(unname(cov)))
}
vcv.matrix <- function(tree, alpha, sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, alpha, sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
colnames(V) <- tree$tip.label
rownames(V) <- tree$tip.label
return(V)
}
sd_logL_vcv <- function(tree, continuousChar, alpha, sigma2, theta){
alpha = alpha[sort(names(alpha))]
sigma2 = sigma2[sort(names(sigma2))]
theta = theta[sort(names(theta))]
theta = as.matrix(theta, nrow = 3)
ntip <- length(tree$tip.label)
V = vcv.matrix(tree, alpha, sigma2)
W = weight.matrix(tree, alpha)
C = chol(V) # upper triangular matrix
L = t(C) # lower triangular matrix
log_det_V = 0
for (i in 1:ntip){
log_det_V = log_det_V + log(L[i,i])
}
log_det_V = log_det_V * 2.0 # equals to julia implementation to 12 sig. fig.
y = NULL
for (species in tree$tip.label){
y[species] = as.numeric(continuousChar[species])
}
# inverse of L
r = solve(L) %*% y - solve(L) %*% W %*% theta # what does de-correlated residuals mean?
# res = - (n/2) * log(2*pi) - 0.5 * log_det_V - 0.5 * dot(r, r)
#     = exp(-n/2)^(2*pi) * exp(-0.5)^det_V * exp(-0.5)^dot(r, r) ?
res = 0.0
res = res - (ntip/2) * log(2*pi)
res = res - 0.5 * log_det_V
res = res - 0.5 * dot(r, r) # is it dot product? what is dot product of r?
return(res)
}
i
i=2
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
i=2
alpha[1] <- metadata$alpha_Br[i]
alpha[2] <- metadata$alpha_Gr[i]
alpha[3] <- metadata$alpha_MF[i]
sigma2[1] <- metadata$sigma2_Br[i]
sigma2[2] <- metadata$sigma2_Gr[i]
sigma2[3] <- metadata$sigma2_MF[i]
theta[1] <- metadata$theta_Br[i]
theta[2] <- metadata$theta_Gr[i]
theta[3] <- metadata$theta_MF[i]
names(alpha) <- c("0", "1", "2")
names(sigma2) <- c("0", "1", "2")
names(theta) <- c("0", "1", "2")
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
for (i in 1:1000){
tree <- alltrees[[i]]
#root_state[i] <- names(tree$maps[[1]][1])
alpha <- c()
sigma2 <- c()
theta <- c()
alpha[1] <- metadata$alpha_Br[i]
alpha[2] <- metadata$alpha_Gr[i]
alpha[3] <- metadata$alpha_MF[i]
sigma2[1] <- metadata$sigma2_Br[i]
sigma2[2] <- metadata$sigma2_Gr[i]
sigma2[3] <- metadata$sigma2_MF[i]
theta[1] <- metadata$theta_Br[i]
theta[2] <- metadata$theta_Gr[i]
theta[3] <- metadata$theta_MF[i]
names(alpha) <- c("0", "1", "2")
names(sigma2) <- c("0", "1", "2")
names(theta) <- c("0", "1", "2")
#logL$R_pruning[i] <- sd_logL_pruning(tree, brain, alpha, sigma2, theta)
logL$R_vcv[i] <- sd_logL_vcv(tree, brain, alpha, sigma2, theta)
}
View(logL)
save(logL, "output/likelihood_comparison_across_methods.Rda")
?save
save(logL, file="output/likelihood_comparison_across_methods.Rda")
load("output/likelihood_comparison_across_methods.Rda")
View(logL)
sort(logL)
logL %>%
sorted()
library(ape)
library(pracma)
library(phytools)
library(slouch)
library(tibble)
library(tidyverse)
logL %>%
sort(decreasing = TRUE)
sort(logL$rb, decreasing = TRUE)
sort(logL$rb, decreasing = FALSE)
plot(sort(logL$rb))
plot(log(sort(logL$rb)))
log(logL$rb)
sapply(logL$rb, function x log(x))
sapply(logL$rb, function(x) log(x))
sapply(logL$rb, FUN = log)
class(logL$rb)
ggplot(logL) +
geom_line(aes(y=rb))
ggplot(logL) +
geom_line(aes(x=1:1000,y=rb))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb)))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb), size=2))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb), linewidth=2, alpha=0.5))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb), linewidth=2, alpha=0.3))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb), linewidth=1.5, alpha=0.3))
ggplot(logL) +
geom_line(aes(x=1:1000,y=sort(rb), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb))) +
geom_point(aes(x=1:1000,y=sort(R_pruning), shape=16)) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb))) +
geom_point(aes(x=1:1000,y=sort(R_pruning), pc=16)) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb))) +
geom_point(aes(x=1:1000,y=sort(R_pruning))) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb), col="red")) +
geom_point(aes(x=1:1000,y=sort(R_pruning))) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb), col="red")) +
geom_point(aes(x=1:1000,y=sort(R_pruning), col="blue")) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb), col="red"), shape=16) +
geom_point(aes(x=1:1000,y=sort(R_pruning), col="blue")) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb), col="red"), shape=16) +
geom_point(aes(x=1:1000,y=sort(R_pruning), col="blue"), shape=4) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb), col="red"), shape=1) +
geom_point(aes(x=1:1000,y=sort(R_pruning), col="blue"), shape=4) +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.5)
ggplot(logL) +
geom_point(x=1:1000,y=sort(rb), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.3), linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv), alpha=0.1), linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.1, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(log(rb))), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4, col="blue") +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4) +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(random(rb))), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4) +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
ggplot(logL) +
geom_point(aes(x=1:1000,y=sort(rb)), alpha=0.5, shape=1, col="red") +
geom_point(aes(x=1:1000,y=sort(R_pruning)), alpha=0.5, shape=4) +
geom_line(aes(x=1:1000,y=sort(R_vcv)), alpha=0.2, linewidth=1.8)
