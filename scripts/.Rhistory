library(ape)
tree <- read.tree("data/1_validation/dummy_threetaxon_stateless.tre")
a = 0.1234
b = 0.2345
c = 0.3456
alpha = 0.1
theta = 0.1
sigma2 = 0.1
Ya = theta * ( 1 - exp(alpha * 0.7)) + exp( alpha * 0.7 ) * a
Yb = theta * ( 1 - exp(alpha * 0.7)) + exp( alpha * 0.7 ) * b
Va = sigma2 / 2 / alpha * ( exp( 2 * alpha * 0.7) - 1 ) + exp(2 * alpha * 0.7 ) * 0
Vb = sigma2 / 2 / alpha * ( exp( 2 * alpha * 0.7) - 1 ) + exp(2 * alpha * 0.7 ) * 0
contrast_ab = Ya - Yb
VarC_ab = Va + Vb
lnl_ab = log(exp( alpha * 0.7 + alpha * 0.7 - contrast_ab^2 / 2 / VarC_ab ) / sqrt( 2 * pi * VarC_ab ))
ab = ( Ya * Vb + Yb * Va ) / ( Va + Vb )
V_pre_ab = ( Va * Vb ) / ( Va + Vb )
Yc = theta * ( 1 - exp( alpha * 1.0 )) + exp( alpha * 1.0 ) * c
Yab = theta * ( 1 - exp( alpha * 0.3 )) + exp( alpha * 0.3 ) * ab
Vc = sigma2 / 2 / alpha * ( exp( 2 * alpha * 1.0 ) - 1 ) + exp( alpha * 1.0 ) * 0
Vab = sigma2 / 2 / alpha * ( exp( 2 * alpha * 0.3) - 1 ) + exp( alpha * 0.3 ) * V_pre_ab
contrast_abc = Yc - Yab
VarC_abc = Vc + Vab
lnl_ab_c = log(exp( alpha * 1.0 + alpha * 0.3 - contrast_abc^2 / 2 / VarC_abc ) / sqrt( 2 * pi * VarC_abc ))
lnl_a_b_c = lnl_ab + lnl_ab_c
root = ( Yc * Vab + Yc * Vab ) / ( Vc + Vab )
Vroot = ( Vc * Vab ) / ( Vc + Vab )
lnproot = log(exp(( root - theta )^2 / ( 2 * Vroot )) / sqrt( 2 * pi * Vroot ))
lnl_everything = proot + lnl_a_b_c
lnl_everything = lnproot + lnl_prooa_b_c
lnl_everything = lnproot + lnl_a_b_c
lnl_everything
library(ape)
library(pracma)
library(phytools)
library(slouch)
library(tibble)
library(tidyverse)
# test with slouch data set
# compare stateless_vcv and stateless_pruning
data("artiodactyla")
data("neocortex")
neocortex <- neocortex[match(artiodactyla$tip.label, neocortex$species), ]
neocortex
diet <- as.character(neocortex$diet)
names(diet) <- neocortex$species
set.seed(123)
smaptree <- phytools::make.simmap(artiodactyla, diet)
plot(smaptree)
tree <- make.simmap(artiodactyla, diet)
plot(tree)
nodesBeforeDiverge <- function(tree, tip1, tip2){
k <- ape::mrca(tree)[tip1, tip2]
x <- k
common_nodes <- c()
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(x, parentNode(tree, k))
x <- tail(k, n = 1)
}
return(k)
}
nodesBeforeDiverge(tree, 1, 3)
nodesBeforeDiverge(tree, 2, 3)
# find parent node by providing child node
parentNode <- function(tree, x){
m <- which(tree$edge[, 2] == x)
return(tree$edge[m, 1])
}
# find nodes along a lineage towards root node by providing initial child (presumably tip) node
nodesAlongLineage <- function(tree, x){
k <- x
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(k, parentNode(tree, x))
x <- tail(k, n = 1)
}
return(k)
}
# find subedges of a lineage
lineage.constructor <- function(tree, e){
nodes <- nodesAlongLineage(tree, e)
## Simmap splits up each edge into sub-edges, depending on the split. So, we use edges instead of nodes, and introduce sub-edges
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
#all_states <- colnames(tree$mapped.edge)
state_changes <- names(subedge_lengths) # from tip to root
state_changes <- c(state_changes, state_changes[length(state_changes)]) # add root state, assuming root state equals the state of the closest subedge
#lineage$state_indicator <- lapply(all_states, function(x) {res <- match(lineage$state_changes, x); res[is.na(res)] <- 0; return(res)})
#names(lineage$state_indicator) <- all_states
# recording time-related numbers of each subedge (root is a subedge with length = 0)
time_point <- cumsum(c(0, unname(subedge_lengths))) # tip
time_begin <- c(tail(time_point, n = -1), tail(time_point, n = 1)) ## older end of subedge
time_end <- time_point ## younger end of subedge
time_span <- c(unname(subedge_lengths), 0) # time at root and each subedge
return(tibble(state_changes = state_changes,
time_begin = time_begin,
time_end = time_end,
time_span = time_span))
}
# not yet finished - weight matrix function
weights.lineage <- function(tree, named_alpha, e){
lineage <- lineage.constructor(tree, e)
lineage[["alpha"]] = named_alpha[lineage[["state_changes"]]]
lineage <- lineage %>% mutate(exp_1 = exp(-alpha * time_end) - exp(-alpha * time_begin),
exp_2 = alpha * lineage$time_span)
ancestral_state <- lineage$state_changes[length(lineage$state_changes)]
weight_ancestral = lineage %>%
summarise(ancestral = exp(-1 * sum(exp_2))) %>%
unlist()
names(weight_ancestral) <- ancestral_state
weights <- lineage %>%
group_by(state_changes) %>%
summarise(weight = sum(exp_1) * exp(-1 * sum(exp_2)))
weights$weight[which(weights$state_changes == ancestral_state)] = weights$weight[which(weights$state_changes == ancestral_state)] + weight_ancestral
#weight_states <- weights$weight
#names(weight_states) <- weights$state_changes
#weight_states[which(names(weight_states) == ancestral_state)] = weight_states[which(names(weight_states) == ancestral_state)] + weight_ancestral
#weight_matrix = weight_matrix / sum(weight_matrix)
weight_matrix <- matrix(nrow = length(named_alpha))
rownames(weight_matrix) <- c(names(named_alpha))
for (rowname in rownames(weight_matrix)){
if (rowname %in% weights$state_changes){
weight_matrix[rowname,] = weights$weight[which(weights$state_changes == rowname)]
}
else {
weight_matrix[rowname,] = 0
}
}
# normalise the weights so that sum(weights) == 1
weight_matrix = weight_matrix/sum(weight_matrix)
return(weight_matrix)
}
# combine to form weight matrix
weight.matrix <- function(tree, named_alpha){
ntip = length(tree$tip.label)
weight_matrix = matrix(nrow = ntip, ncol = length(named_alpha))
rownames(weight_matrix) <- c(1:ntip)
colnames(weight_matrix) <- c(names(named_alpha))
for (i in 1:ntip){
weight_matrix[i,] <- weights.lineage(tree, named_alpha, i)
}
return(weight_matrix)
}
nodesBeforeDiverge(tree, 2, 3)
nodesBeforeDiverge(tree, 2, 20)
nodesBeforeDiverge(tree, 15, 20)
nodesBeforeDiverge(tree, 15, 42)
nodesBeforeDiverge(tree, 41, 42)
nodesBeforeDiverge(tree, 41, 1)
nodesBeforeDiverge(tree, 30, 42)
ape::mrca(tree)
k <- ape::mrca(tree)
View(k)
tip1 = 7
tip2 = 8
k <- ape::mrca(tree)[tip1, tip2]
x <- k
N <- length(tree$tip.label)
nodesBeforeDiverge <- function(tree, tip1, tip2){
k <- ape::mrca(tree)[tip1, tip2]
x <- k
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(x, parentNode(tree, x))
x <- tail(k, n = 1)
}
return(k)
}
nodesBeforeDiverge(tree, 30, 42)
nodesBeforeDiverge(tree, 7, 8)
k <- ape::mrca(tree)[tip1, tip2]
x <- k
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(x, parentNode(tree, x))
x <- tail(k, n = 1)
}
k <- ape::mrca(tree)[tip1, tip2]
x <- k
parentNode(tree, x)
nodesBeforeDiverge <- function(tree, tip1, tip2){
k <- ape::mrca(tree)[tip1, tip2]
x <- k
N <- length(tree$tip.label)
while(x != N + 1){
k <- c(k, parentNode(tree, x))
x <- tail(k, n = 1)
}
return(k)
}
nodesBeforeDiverge(tree, 7, 8)
tip = tip1
nodes <- nodesAlongLineage(tree, tip)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
edges
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
subedge_lengths
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)])
unique(diet)
named_alpha = c("MF" = 3, "Gr" = 4, "Br" = 5)
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)])
subedge_lengths
subedge_lengths %>%
mutate(sum2 = time_span * alpha)
subedge_lengths %>%
mutate(sum2 = time_span * alpha) %>%
reframe(sum = sum(sum2))
sum2 <- subedge_lengths %>%
mutate(sum2 = time_span * alpha) %>%
reframe(sum = sum(sum2)) %>%
unlist() %>%
unname()
sum2
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
subedge_lengths
age_root0tip1 <- ape::node.depth.edgelength(tree)
tree
age_root0tip1
ape::node.depth.edgelength(tree)[44]
max(age_root0tip1)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
mcra_time
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
time_point
tb <- c(tail(time_point, n = -1)) ## older end of subedge
tb
te <- c(head(time_point, n = -1)) ## younger end of subedge
te
named_sigma2 <- named_alpha
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
times
times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end)))
times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end))) %>%
reframe(sum1 = sum(exp))
sum1 <- times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
sum1
times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end)))
v.sum1 <- function(tree, tip1, tip2, named_alpha, named_sigma2){
nodes <- nodesBeforeDiverge(tree, tip1, tip2)
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
age_root0tip1 <- ape::node.depth.edgelength(tree)
mcra_time <- max(age_root0tip1) - age_root0tip1[nodes[1]]
time_point <- cumsum(c(mcra_time, unname(subedge_lengths))) # tip
tb <- c(tail(time_point, n = -1)) ## older end of subedge
te <- c(head(time_point, n = -1)) ## younger end of subedge
times <- tibble(time_span = unname(subedge_lengths),
time_begin = tb,
time_end = te,
alpha = named_alpha[names(subedge_lengths)],
sigma2 = named_sigma2[names(subedge_lengths)])
sum1 <- times %>%
mutate(exp = sigma2 / (2 * alpha) * (exp(2 * alpha * time_begin) - exp(2 * alpha * time_end))) %>%
reframe(sum1 = sum(exp)) %>%
unlist() %>%
unname()
}
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
v.sum2 <- function(tree, tip, named_alpha){
nodes <- nodesAlongLineage(tree, tip)
#nodes1 <- output[[1]]
#nodes_common <- output[[3]]
edges <- which(tree$edge[,2] %in% nodes) # from tip to root
subedge_lengths <- rev(unlist(lapply(edges, function(i) tree$maps[[i]]))) # from tip to root
subedge_lengths <- tibble(time_span = subedge_lengths,
alpha = named_alpha[names(subedge_lengths)])
#edges_common <- which(tree$edge[,2] %in% nodes_common) # from tip to root
#subedge_lengths_common <- rev(unlist(lapply(edges_common, function(i) tree$maps[[i]])))
sum2 <- subedge_lengths %>%
mutate(sum2 = time_span * alpha) %>%
reframe(sum = sum(sum2)) %>%
unlist() %>%
unname()
return(sum2)
}
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
tip2 = 16
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
v_ij <- exp2 * sum1
named_sigma2[[1]] = 0.1
named_sigma2[[2]] = 0.2
named_sigma2[[3]] = 0.3
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
named_alpha[[1]] <- 1.1
named_alpha[[2]] <- 1.2
named_alpha[[3]] <- 1.3
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
v_ij <- exp2 * sum1
vcv.pairwise <- function(tree, named_alpha, named_sigma2, tip1, tip2){
sum2_tip1 <- v.sum2(tree, tip1, named_alpha)
sum2_tip2 <- v.sum2(tree, tip2, named_alpha)
exp2 <- exp(-1 * (sum2_tip1 + sum2_tip2))
sum1 <- v.sum1(tree, tip1, tip2, named_alpha, named_sigma2)
v_ij <- exp2 * sum1
return(v_ij)
}
for (row in V) {
}
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
for (row in V) {
}
print(row)
for (row in V) {
print(row)
}
V
j = ntip
## issues:
## values should be non-negative!!
##
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
return(V)
}
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
V
C = chol(V) # upper triangular matrix
C
e = 16
lineage <- lineage.constructor(tree, e)
lineage
lineage[["alpha"]] = named_alpha[lineage[["state_changes"]]]
lineage
lineage %>% mutate(exp_1 = exp(-alpha * time_end) - exp(-alpha * time_begin),
exp_2 = alpha * lineage$time_span)
lineage %>% mutate(exp_1 = exp(-alpha * time_begin) - exp(-alpha * time_end),
exp_2 = alpha * lineage$time_span)
lineage <- lineage %>% mutate(exp_1 = exp(-alpha * time_begin) - exp(-alpha * time_end),
exp_2 = alpha * lineage$time_span)
ancestral_state <- lineage$state_changes[length(lineage$state_changes)]
ancestral_state
weight_ancestral = lineage %>%
summarise(ancestral = exp(-1 * sum(exp_2))) %>%
unlist()
names(weight_ancestral) <- ancestral_state
weight_ancestral
lineage %>%
group_by(state_changes) %>%
summarise(weight = sum(exp_1) * exp(-1 * sum(exp_2)))
lineage <- lineage.constructor(tree, e)
lineage[["alpha"]] = named_alpha[lineage[["state_changes"]]]
lineage <- lineage %>% mutate(exp_1 = exp(-alpha * time_end) - exp(-alpha * time_begin),
exp_2 = alpha * lineage$time_span)
ancestral_state <- lineage$state_changes[length(lineage$state_changes)]
weight_ancestral = lineage %>%
summarise(ancestral = exp(-1 * sum(exp_2))) %>%
unlist()
names(weight_ancestral) <- ancestral_state
weights <- lineage %>%
group_by(state_changes) %>%
summarise(weight = sum(exp_1) * exp(-1 * sum(exp_2)))
weights
weights$weight[which(weights$state_changes == ancestral_state)] = weights$weight[which(weights$state_changes == ancestral_state)] + weight_ancestral
weights
weight_ancestral
#weight_matrix = weight_matrix / sum(weight_matrix)
weight_matrix <- matrix(nrow = length(named_alpha))
rownames(weight_matrix) <- c(names(named_alpha))
for (rowname in rownames(weight_matrix)){
if (rowname %in% weights$state_changes){
weight_matrix[rowname,] = weights$weight[which(weights$state_changes == rowname)]
}
else {
weight_matrix[rowname,] = 0
}
}
weight_matrix
# normalise the weights so that sum(weights) == 1
weight_matrix = weight_matrix/sum(weight_matrix)
weight_matrix
V = vcv.matrix(tree, named_alpha, named_sigma2)
W = weight.matrix(tree, named_alpha)
W
V
C = chol(V) # upper triangular matrix
?chlo
?chol
colnames(V) <- tree$tip.label
rownames(V) <- tree$tip.label
V
## issues:
## values should be non-negative!!
##
vcv.matrix <- function(tree, named_alpha, named_sigma2){
ntip <- length(tree$tip.label)
V <- matrix(nrow = ntip, ncol = ntip)
j = ntip
while (j != 0){
for (i in 1:ntip){
V[i,j] <- vcv.pairwise(tree, named_alpha, named_sigma2, i, j)
V[j,i] <- V[i,j]
}
j = j-1
}
colnames(V) <- tree$tip.label
rownames(V) <- tree$tip.label
return(V)
}
names(weight_matrix) <- tree$tip.label
# combine to form weight matrix
weight.matrix <- function(tree, named_alpha){
ntip = length(tree$tip.label)
weight_matrix = matrix(nrow = ntip, ncol = length(named_alpha))
rownames(weight_matrix) <- c(1:ntip)
colnames(weight_matrix) <- c(names(named_alpha))
for (i in 1:ntip){
weight_matrix[i,] <- weights.lineage(tree, named_alpha, i)
}
names(weight_matrix) <- tree$tip.label
return(weight_matrix)
}
V = vcv.matrix(tree, named_alpha, named_sigma2)
W = weight.matrix(tree, named_alpha)
W
